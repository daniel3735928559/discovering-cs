<?xml version="1.0" encoding="UTF-8"?><?xml-stylesheet href="box.xsl" type="text/xsl"?><section number="2">
  <title>Chapter 2</title>
  <section>
    <title>Programming as a means of making systems</title>

    <text>

<figure><caption>We are now going to study programming at a high level
(low-level programming will happen at the ISA
layer).</caption></figure>
      
<p>Let us start by situating ourselves within the tower of
abstractions we laid out in the previous chapter: We are trying to
understand computers--that is, devices that perform arithmetic,
logical, memory, and I/O operations.  Specifically, we are trying to
understand two things: </p>

<ul><li>How to program a computer</li>
<li>How to build a computer</li></ul>

<p>Recall we said that to program such a device, we would provide it
with sequences of commands from its ISA.  But because the ISA provides
only basic commands, we prefer to write commands in a more
human-friendly form and then have a mechanical way of translating
those commands into the basic ISA commands that the computer
understands.  A human-friendly way of specifying what the computer
should do is called a <b>high-level programming language</b>.  </p>

<warning><p>The computer doesn't itself understand the programming
language, as mentioned.  However at this level, we are actually not
interacting directly with the computer at all, but rather with the
compiler--the mechanism for translating a high-level programming
language into ISA operations for the computer's consumption.</p>

<p>Nevertheless, we may sometimes in this chapter speak imprecisely by
talking about the computer itself actually understanding the
programming language, when really we mean the compiler--the
abstraction currently sitting between us and the computer--is helping
the computer understand it.  That is, we are describing the interface
of the compiler, and so from this perspective, programming the
compiler looks like programming the computer.</p>
</warning>

<p>In this chapter, we'll discuss the concept of a program and a
programming language in general in 2.2, as well as strategies for
writing effective programs.  Then, starting in 2.3, we'll introduce an
actual programming language: Python, and will walk through the process
of writing Python programs to solve specified problems.  </p>

<p><def term='programming'>Most generally, <b>programming</b> is expressing to the computer: 
<ul><li>A sequence of steps for it to perform--also known as a <b>program</b></li>
<li>specified in way that the computer understands--also known as a <b>programming language</b></li></ul>
</def>

<def term="executing">When the computer subsequently executes the steps you gave it, it is
said to be <b>running</b> or <b>executing</b> the program.  </def></p>

<p>In general, you approach a computer with a human-level problem: You want to find out how much you spend on cookies each month, or maybe you want to make a Pacman clone.  However a computer has no understanding of such things--It does not know what a cookie is and does not come with a command for "play pacman".  But it does (at least, at the level we're thinking about it currently) provide you with a programming language--that is, you can tell it to do certain specific operations that are allowed by the language.  Beyond that, a computer is a machine--if you give it a sequence of commands in a programming language, it very simply does everything listed in that program, and nothing else.  It has no understanding of--let alone sympathy for--its owner's 'intent'.  </p>

<code>A classic parable--"If your husband were a computer": 

"Honey, while you're out, could you stop by the store and buy one
carton of milk?  And if they have eggs, get 6."  

A short time later the husband comes back with 6 cartons of milk.

The wife is perplexed.  "Why did you buy 6 cartons of milk?"

"They had eggs!"</code>

<p>This is the gap that a programmer has to bridge: Taking a high-level problem coming from the real world, and turning it into a sequence of steps that are allowed in a given programming language.  </p>

<p>In this chapter, we'll do three things: 

<ol><li>In 2.2, we'll discuss the first step in crossing this gap: Algorithms.  An algorithm is a human-readable description of computer-friendly steps intended to solve a high-level problem.  There are a few considerations that come into play when designing an algorithm--how "good" is a particular algorithm for solving a problem, and what does "good" even mean for algorithms.  </li>

<li>Then, in 2.3, and 2.4, we'll take the next step: Once we've got the algorithm--the computer-friendly steps that solve the problem--we need the program.  That is, we need to write those steps in a computer-friendly way.  So we'll introduce a specific programming language--Python, talking only about the rules about what instructions are allowed in a valid Python program (also known as Python's syntax, and discussed in 2.4), and what specific valid instructions actually do (Python's semantics, discussed in 2.5).  </li>

<li>Finally, in 2.5 and 2.6, we'll go through examples of ever-increasing complexity that put this whole process together: Starting with a general problem, constructing an algorithm that solves it in a computer's terms, and then turning that algorithm into a program so that the computer can find the actual solutions for us.  </li></ol></p>
    </text>
  </section>


  <section>
    <title>Algorithms: Expressing solutions in human language, but in terms of the computer's primitives</title>
    <summary><p>The first step in programming a computer with the
    solution to some given problem is to figure out what are the steps
    it will need to perform.  Each step must consist, fundamentally,
    of only operations of the four basic sorts that a computer can
    perform.  </p>

    <p>It is at this point--while writing the algorithm and in
    particular before writing any actual computer code--that we can
    assess our solution's efficiency as well as identify in what
    situations our solution would not work.  This can consist either
    of rare special cases of the problem in question--called
    edge-cases, or of simply scaling up the size of the problem until
    our solution wouldn't be able to handle it within a reasonable
    amount of time.</p></summary>

    <text>
      
      <p>Suppose you've written a computer game, which has 3 players,
      each of whom has a score.  At the game's end, you'd like to
      determine a winner.  To a human, looking at the three scores and
      picking out the largest one is completely straightforward.
      After all, "pick the largest of three numbers" seems like an
      atomic operation in its own right--one which we never have to
      think about breaking down into a more precise, step-by-step
      procedure.</p>

<p>However such a step-by-step procedure is exactly what a computer needs in order to accomplish this same goal.  It doesn't have a "find the largest number" operation built-in.  Instead, its available operations are basic: Things like "add two numbers", "compare two numbers", and the like.  </p>

<p>First of all, we know the computer can store numbers.  In fact, as we will see later, you can store numbers under names of your choosing, so suppose we've stored the three players' scores under the names score1, score2, and score3 respectively.  Then a procedure for determining the winner might look like: </p>

<code>If score1 is greater than score2 and score1 is also
greater than score3: Display the text: "PLAYER 1 WINS!"

If not, then if score2 is greater than score1 and score2 is also
greater than score3: Display the text: "PLAYER 2 WINS!"

If not, then if score3 is greater than score1 and score3 is also
greater than score2: Display the text: "PLAYER 3 WINS!"
<caption>An algorithm for determining the winner of a 3-player game given
the scores</caption></code>

<p>This procedure can now believably be broken down into simple arithmetic operations: Comparing two numbers is an operation the computer can do, and the simple logic operation "if both this and that are true" is another, so indeed, the above does comprise a computer-friendly procedure.  It is not yet a program because it was still written in English, rather than in a language the computer understands, but it is a complete description of computer-friendly steps for accomplishing what we need done.  Recall that such a precisely specified procedure we called an algorithm.  </p>

<p>There are two things that might give you pause about this algorithm as written:  namely, it's handling of ties, and its apparent inefficiency.  </p>

    </text>
    <section>
      <title>Edge-cases</title>
      <summary><p>Edge-cases are situations that are unusual or
      unexpected, but may nonetheless occur.  A simple example of this
      is a tied score in a game.  Sloppy algorithms may work under
      normal circumstances but break down when faced with certain
      edge-cases.</p></summary>
      <text>
	<p>When you sit down to write an algorithm, you should have
	some understanding of what you can and cannot expect of the
	inputs.  For instance, try to follow through the above
	algorithm if <pre>score1 = 10, score2 = 10, score3 = 7</pre>.
	It doesn't print anything at all!  <def term='edge-case'>Such
	inputs are sometimes called <b>corner-cases</b> or
	<b>edge-cases</b>.  They are not generally what your algorithm
	will have to deal with, but they can still happen in theory,
	and when they do, they can give you a rather bad day if you
	haven't accounted for them.</def> Indeed, failing to deal with
	even a single sneaky corner-case is a common cause of serious
	problems in real-world programming.</p>

	<p>For now, for simplicity, we'll assume the rest of the game
	is set up so that any tie is resolved with a tie-breaker, so
	that in fact, by the time the algorithm above is run, there
	are no remaining ties.  </p>

	<p>This is one perfectly valid way of dealing with
	corner-cases: Just add some further steps that ensure that
	they can honestly never appear.  This decision comes from
	asking the higher-level question of how we in fact want the
	game to work.  If we really don't want there to be ties in the
	end (e.g. we always make it so there are tiebreaker rounds
	until all ties are resolved), then we may do as we suggested.
	But if we actually think ties should be a valid result in our
	game, then we would have to expand our score-comparison
	algorithm to deal with this and detect them.</p>
      </text>
    </section>
    <section>
      <title>Efficiency</title>
      <summary><p>Simply having an algorithm that solves the problem
      given doesn't have to be the end of the story.  We can ask
      whether there is a more "efficient" algorithm, where "efficient"
      may mean anything from "takes less time to finish in every
      situation" to "requires more storage space to finish in some
      cases, but requires way less storage in the few cases we
      actually expect to run into".  </p></summary>
      <text>
	<p>There are two things about this algorithm's inefficiency
	that might offend your sensibilities: We're comparing three
	numbers, so it seems like the number of actual "compare these
	two numbers" operations required shouldn't be too many.  But
	indeed, if score3 happens to be the largest number, then the
	above algorithm will perform this operation 6 times: </p>

	<p>We first compared score1 to score2 and then to score3.
	Since score1 wasn't the largest, we then compared score2 to
	score1 and to score3.  Since score2 was also not the largest,
	we finally compared score3 to score1 and to score2, and saw
	that score3 was indeed larger than the other two.  This
	intuitively seems a lot more work than your brain is likely
	doing when you simply look at three numbers and spot the
	largest by eye, so it might be worth looking for an improved
	algorithm that will involve less work from the computer.  </p>

	<p>By contrast, consider the following algorithm: </p>

<code>If score1 > score2, then do the following: If score1 > score3,
Display "Player 1 wins", or else display "Player 3 wins!"

Otherwise, do the following: If score2 > score3, Display "Player 2
wins", or else display "Player 3 wins!"<caption>A slightly more
efficient algorithm for comparing three scores</caption></code>

<p>This algorithm has three comparisons written into it, but it will
only ever perform two of them regardless of what the scores are,
making it three times as fast as the original algorithm, at least in
the event that player 3 wins.  </p>

<p>(As an aside: It is worth revisiting the question of edge-cases
with this improved algorithm, and noting that while our previous
algorithm printed nothing in case of a tie, this one may actively
print the wrong thing--try it and see!)</p>

<p><def term="efficiency">This is an example of analyzing an
algorithm's <b>efficiency</b>--that is, analyzing how much of a given
resource an algorithm may require under various circumstances.</def>
That definition is intentionally quite vague: "Resources" may refer to
time, or memory, or communication bandwidth, or money, or any other
thing required by the algorithm that we may wish to study.  "Various
circumstances" may refer to asking about how the algorithm behaves in
the most common case, or in the average case, or in the worst possible
case.  </p>

<p>Which notion of efficiency you consider in your algorithm design
depends on circumstances usually outside the original problem
statement--do you have lots of money and no time?  An algorithm that
is highly inefficient in its use of memory even in the common case,
but very efficient in its use of time, even in the worst case, may be
what you want.</p>

<p>The conclusion that we arrived at in our comparison of the two "who
won?" algorithms, stated precisely, would be that they require the
same amount of memory (both have to store exactly three values), but
that in the worst case, the first algorithm would require six
comparisons to be performed whereas the second would require only
two.</p>

<warning><p> Even our mention of "time" as a resource was a little
imprecise.  Remember that when a computer runs a program, what it is
actually doing is running ISA operations.  Generally, each ISA
operation takes a fixed number of microseconds, so to study how long a
program takes, we technically have to understand what ISA operations
it corresponds to and ask how many of these will be executed.</p>

<p>Counting the number of steps or arithmetic operations used by the
algorithm is often a useful proxy for this more precise notion, but as
you get more involved with high-level languages, the more
disassociated "number of steps in your program" becomes from "number
of ISA operations involved".  If we wish to make our programs more
efficient, then, it can be crucial to understand them at the ISA
level.  We will see examples of this in chapter 5.  </p></warning>

      </text>
    </section>
    <section>
      <title>Scalability</title>
      <summary>If we take our algorithm that solves a problem and
      become very successful, sometimes we end up facing a much bigger
      version of our original problem.  Maybe our game only had three
      players to begin with, but what if it becomes popular and now
      has a million?  This is another measure of an algorithm--how
      well it behaves when faced with larger and larger versions of
      the problem it was meant to solve.  In other words, how well it
      "scales".</summary>
      <text>
<p>There is a related but more subtle concern about the original
algorithm, which is: Suppose instead we had 10 players?  Or 100?  What
would it look like then?  </p>

<p>The structure of the algorithm was:</p>

<code>First do all the comparisons to see if player 1 won.

If player 1 didn't win, then do all the comparisons to see if player 2
won.

etc.</code>

<p>So in the case of 10 players, it looks like:</p>

<code>If score1 > score2 and score1 > score3 and ... and score1 >
score10, then display "Player 1 wins!"

Otherwise, if score2 > score1 and score2 > score3 and ...

..............</code>

<p>Before, if player 3 won, we had to do 6 whole comparisons to find this out.  Now there are 10 players who might have won, and testing each requires 9 comparisons, so we get a total of 90 comparisons that might have to happen before we can determine a winner!  In general, for N players, we have N*(N-1) comparisons--so for 100 players, that's 9900 comparisons!</p>

<p>These numbers might seem notionally problematic, but it is possible
to assess the actual cost in time and energy to say something
objective: An average computer might say it is "clocked at a 1 GHz".
That means it can do a one billion basic operations every second.  If
you're running a massively multiplayer online game with 10000 players,
then using this algorithm, each winner calculation will take at least
99990000, or roughly one hundred million operations.  With a 1 GHz
computer, we can thus only compute a winner around 10 times per
second.  And if we want to constantly be displaying the current leader
on the screen as the game progresses, this means the game can only
update the display 10 times per second at most (i.e. run the game at
what 10 "frames per second").  But the illusion of smoothness in
gameplay comes from updating the picture on the screen at the very
least 30 times per second, so limiting a game to 10 frames per second
would result in noticeable stuttering and could easily render the game
unplayable.  </p>

<p><def term="scalability">This is an analysis of
<b>scalability</b>--that is, of questions about how well the algorithm
performs when we apply it to scaled-up versions of the same problem,
and about how big the problem can become before we are forced to
modify our algorithm to solve it effectively.</def></p>

<p>Whether scalability is a concern for your particular application is
again more a question of your philosophy, ambitions, and external
constraints.  If you're really honestly only ever going to have three
players, then reducing 6 operations to 2 on a computer that can
perform billions every second, and putting a lot of effort in to make
your program works for thousands of people at a time when that scale
is very far in your project's future may or may not be the best use of
your time right at the start of such a project.  </p>
      </text>
    </section>
    
  </section>

  <section>
    <title>Python: Expressing algorithms using a programming language</title>
    <text>
      <p>Now we come to the second step in using a computer to solve a
      problem.  We have the algorithm describing the steps the
      computer can take to solve it.  Now we need to write those steps
      in a language the computer understands--a <b>programming
      language</b>.  In this section, we'll be introducing the rules
      governing a specific programming language--Python.  </p>
      
      <p>In this section, we'll provide a basic introduction to the
      language and get you running your first program.  In the
      subsequent sections, we'll introduce the <def term="syntax">
      <b>syntax</b>--that is, what are the rules that determine
      whether the instructions in a program are valid</def>, and the
      <b>semantics</b>--<def term='semantics'> that is, what do the
      various instructions actually do.</def></p>

      <p>In this chapter alone, we will discuss only a subset of
      Python, which will be sufficient accomplish many goals, at the
      price of being less powerful than the whole Python language
      actually us.  In chapter 3 we shall see some of Python's
      advanced features and how they simplify some of the tasks that
      will be slightly cumbersome in this chapter.</p>

      <p>Finally, as with most computer-related things, you can find
      more information on any specific topic with a studied use of
      your favorite search engine.  If you find yourself confused
      about while loops in Python (whatever those are), punching
      'python while loop' or even 'python while loop tutorial' into
      Google will often have an enlightening effect.</p>
    </text>
    <section>
      <title>Running Python</title>
      <summary>In this book, some examples will be runnable in a
      simulator, which will be included in-line.  Press run to start
      running the program.  Press "step" to advance the program by one
      step.  Change the number in the box next to "step" to make the
      "step" button advance the program by more steps.  The link on
      the left sidebar will let you run a more complete version of the
      simulator.</summary>
      <text>
	<p>Python is a real-world programming language with many uses
	in the wild.  However, in this chapter, since we're focusing
	on a very small part of the Python language, we will not run
	any code on a real computer.  Rather, we will use the web
	browser to simulate the code being run.  This way, we will get
	to watch what happens, as if in slow-motion, as the code is
	executed, rather than it all happening at once and trying to
	work out or imagine what happened afterward.  </p>

	<p>We'll explain the use of the simulator interface and what
	you can do with it throughout this section, but if you're the
	sort of person who would rather play the game without first
	reading the rules, a few example programs and challenges are
	available by clicking the "Python" link on the sidebar, or by
	clicking <a href="tied/quest.html">here</a>.  </p>

	<p>To use the simulator, you write your program in the text
	box on the right.  When ready, click the "run" button above
	it, whereupon the simulation will be prepared.  At this point,
	no changes to the code can be made until you press the "reset"
	button.  To execute a single line of code, click the "step"
	button.  If you want to run more than one step at a time,
	simply enter how many steps you want the step button to
	advance into the input box to the right of it.  </p>

	<p>As you step through the code, the line that will be
	executed the next time you step is highlighted in the program
	text input by a red arrow that will appear next to that line
	in the left-hand margin.</p>

	<p>While you can write and test any program in this simulator,
	some programs right here in the main text will be embedded in
	a smaller version of the simulator so you can step through the
	examples and see how they work and edit them as you please to
	see how various changes affect the behavior.  You can always
	restore the original example program by pressing the "original"
	button.  </p>
      </text>
    </section>
    <section>
      <title>A first Python example</title>
      <summary>We introduce Python by describing a classical
      mathematics problem, writing an algorithm, and then writing the
      corresponding Python code for that algorithm.</summary>
      <text>
	<p>There is a famous mathematical problem--known as the 3x+1
	conjecture--that goes as follows: 

<ol><li>Start with any positive integer.  </li>
<li>If it is even, divide it by 2.  If odd, triple it and add one.
</li>
<li>If the result is 1, stop.  Otherwise, go back to the previous
step.</li>
</ol>

For example, we start with 5:</p>

<table>
<tr><td>Current value</td><td>What do we do next?</td></tr>
<tr><td>5</td><td>5 is odd, so triple and add 1 to get...</td></tr>
<tr><td>16</td><td>16 is even, so divide by 2</td></tr>
<tr><td>8</td><td>8 is even, so divide by 2</td></tr>
<tr><td>4</td><td>4 is even, so divide by 2</td></tr>
<tr><td>2</td><td>2 is even, so divide by 2</td></tr>
<tr><td>1</td><td /></tr>
</table>

<p>The conjecture is that we always get down to 1, regardless of our
start input.  We just verified the conjecture starting with x = 5, but
what about other values of x?  We can start doing some, and it's
pretty easy: For x = 25, for example, it goes: 

<code>25, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40,
20, 10, 5, 16, 8, 4, 2, 1</code>

It takes a little while, but we can sort of do it by hand.  However,
for x = 27, if we start, we get the sequence:

<code>27, 82, 41, 124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161,
484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466,
233, 700, 350, 175, 526, 263, 790, 395, 1186, ......</code>

Which looks like it might possibly continue with its fitful growth
forever.  If only we could get a computer to do the tedious work of
running the algorithm for us...</p>

<p>As described before, the first step in writing a program is to come
up with an algorithm that expresses the procedure in terms of the
kinds of operations a computer can do.  </p>

<code>
1. Store the value 27 in a slot called x (Storage)
2. See if x is equal to 1, and as long as it is not, execute the
   following steps (3-5) and come back to this step:  (Arithmetic and branching)
   3. If x is even, compute x/2 and store that in x (Arithmetic, storage, and branching)
   4. Otherwise, compute 3*x+1 and store that in x (Arithmetic, storage, and branching)
   5. Print out the current value of x (I/O)
6. Print out the text "Done" (I/O)
</code>

<p>We call step 3 ("If x is even...") partly arithmetic because we
compute x/2, and partly storage because we have to store that
somewhere, and partly branching because it's choosing to either
execute a computation or to skip it depending on a certain condition.
However, testing that condition--whether x is even--doesn't seem like
an arithmetic operation in the sense of addition, subtraction,
multiplication, and division.  </p>

<p>The key is that division is actually three separate operations:
Just as in grade school, before you learned to think of 13 divided by
4 as 3.25, you may have instead learned it as "13 divided by 4 is 3
with a remainder of 1".  That is, 4 goes into 13 three times, but then
there's one left over.</p>

<p>In Python, the "/" operation represents the decimal division--so 13
/ 4 is 3.25.  The "//" operation represents integer division--i.e. the
more naive notion of "how many times does this number go into that
one", so 13 // 4 is 3.  <def term="modulus">Finally, the "%" operation
gives the remainder of the integer division, so 13 % 4 is 1.  This
operator is known as the <b>modulus</b> operator.</def></p>

<aside><p>In case you're wondering where this word "modulus" comes
from--it actually comes from an English word "modulo", meaning roughly
"supposing we ignore".  For example, "Bob and Sam basically get along
quite well modulo matters pertaining to cheese".  The reason for its
use here is that 13 = 1 + 4 + 4 + 4, so modulo 4s--i.e. if we ignore
the 4s, 13 is the same as 1.  I.e. "13 modulo 4 is 1", written in
computer lingo as 13 % 4 = 1.</p>
</aside>

<p>The modulus operator gives us a way to test whether a number is
even: "Even" means that when you divide by 2, there is a remainder of
0.  So to test whether x is even, we'll compute x % 2.  If this is 0,
then x is even.  Otherwise, x is odd.  For simplicity, we'll break out
this computation into a separate step in the algorithm: </p>

<code>Store the value 27 in a slot called x (Storage)
See if x is equal to 1, and as long as it is not, execute the
following steps and come back to this step:  (Arithmetic and branching)
   Compute x % 2 and store it in a slot called y (Arithmetic and storage)
   If y is 0, do the following steps: (Branching)
      Compute x/2 and store that in x (Arithmetic and storage)
   Otherwise, do the following steps: (Branching)
      Compute 3*x+1 and store that in x (Arithmetic and storage)
   Print out the current value of x (I/O)
Print out the text "Done" (I/O)
</code>


<p>Now, we said that programming is taking an algorithm and expressing
it in a computer's terms.  To this end, we shall take the above
algorithm and write a Python program that runs it(don't worry if you
don't understand it yet--all will be explained in time): </p>

<python>x = 27
while(x != 1):
   y = x % 2
   if(y == 0):
      x = x / 2
   else:
      x = 3 * x + 1
   print(x)
print("Done")
</python>

<p>Before we jump into studying this program, let's run it to see what
happens: To start the program, press the "run" button.  Then to
advance to the next step in the program, one step at a time, press the
"step" button.  It will of course take a long time of doing this to
run the program through to completion, so we can use the box next to
the step button to say how many steps we want the step button to
advance us.  If you want to see the end result, put something large
like 1000 in and wait and behold the output.  </p>

<p>Now, if you compare this listing to the English language algorithm,
you notice many similarities, but the Python syntax is more rigid: The
computer runs this program by the code one line at a time.  After one
line is run, it moves on to the next line, unless some instruction
tells it to do otherwise.  </p>

<p>This is a fundamental rule, and should be internalized so you can
get used to understanding programs mechanically: Programs are run one
line at a time.  In particular, understanding a program entails not so
much looking at it as a whole, but understanding what each line does
individually.  Generally, once one line's instruction is completed,
the next instruction to be run is the one on the following line,
except in certain situations in which an instruction can tell the
program to jump to a different line.  For example, the block:
</p>

<code>x = 27
<div class='highlight'>while(x != 1):
   y = x % 2
   if(y == 0):
      x = x / 2
   else:
      x = 3 * x + 1
   print(x)</div>print("Done!")
</code>

<p>means that all the indented instructions should be repeated as long
as x is not 1 (which is written in Python as x != 1).  In particular,
when we get to the line </p>

<code>x = 27
while(x != 1):
   y = x % 2
   if(y == 0):
      x = x / 2
   else:
      x = 3 * x + 1
<div class="highlight">   print(x)</div>print("Done!")
</code>

<p>if x still isn't 1, then we don't go to the next line (which is the end of the program!), but instead jump back to the beginning of the indented "while" block--specifically, to the line </p>

<code>x = 27
while(x != 1):
<div class="highlight">   y = x % 2</div>   if(y == 0):
      x = x / 2
   else:
      x = 3*x+1
   print(x)
print("Done!")
</code>

<p>There is a second difference between the English description of the
algorithm and its programmatic realization, namely that whereas when
describing the algorithm, we had a notion of "the current value of the
number", which in the example took on the values "5, 16, 8, 4, 2, 1".
In the program, we have to give the value a name.  In this program, we
have chosen the name "x".  Such a "named value" is called a variable.
Variables are used whenever we want to store the value of a
computation for later use.</p>

<p>In this program, we have two variables, called "x" and "y", whose stored values get updated as the program progresses.  </p>

<p>Using the rule that a program is run one line at a time, we can
follow along with the program, one line at a time, to see: 
<ol><li>Which lines get executed</li>
<li>What values the variables are storing</li></ol></p>

<table>
<tr><td>Current line</td><td>Why we went to this line</td><td>Variables after current line runs</td><td>Output so far</td></tr>
<tr>	 
<td><pre>x = 27</pre></td>
<td>     It was the next line</td>
<td><pre>x = 27</pre></td>
</tr>    

<tr>	 
<td><pre>while(x != 1):</pre></td>
<td>     It was the next line</td>
<td><pre>x = 27</pre></td>
</tr>    

<tr>	 
<td><pre>   y = x % 2</pre></td>
<td>     x was not 1</td>
<td><pre>x = 27, y = 1</pre></td>
</tr>    

<tr>	 
<td><pre>   if(y == 0):</pre></td>
<td>     It was the next line</td>
<td><pre>x = 27, y = 1</pre></td>
</tr>    

<tr>	 
<td><pre>      x = 3*x+1</pre></td>
<td>     y was not 0</td>
<td><pre>x = 82, y = 1</pre></td>
</tr>    

<tr>	 
<td><pre>   print(x)</pre></td>
<td>     It was the next line</td>
<td><pre>x = 82, y = 1</pre></td>
<td>     82</td>
</tr>    

<tr>	 
<td><pre>   y = x % 2</pre></td>
<td>     We reached the end of the while block, but x was not 1, so we go back to the start</td>
<td><pre>x = 82, y = 0</pre></td>
<td>     82</td>
</tr>    

<tr>	 
<td><pre>   if(y == 0):</pre></td>
<td>     It was the next line</td>
<td><pre>x = 82, y = 0</pre></td>
<td>     82</td>
</tr>    

<tr>	 
<td><pre>      x = x / 2</pre></td>
<td>     y was 0</td>
<td><pre>x = 41, y = 0</pre></td>
<td>     82</td>
</tr>    

<tr>	 
<td><pre>   print(x)</pre></td>
<td>     We skip the else block because the if condition was true</td>
<td><pre>x = 41, y = 0</pre></td>
<td>     82
<br />   41</td>
</tr>    

<tr>	 
<td><pre>   y = x % 2</pre></td>
<td>     We reached the end of the while block, but x was not 1, so we go back to the start</td>
<td><pre>x =41, y = 1</pre></td>
<td>     82
<br />   41</td>
</tr>    

<tr>	 
<td><pre>   if(y == 0):</pre></td>
<td>     It was the next line</td>
<td><pre>x = 41, y = 1</pre></td>
<td>     82
<br />   41</td>
</tr>    

<tr>	 
<td><pre>      x = 3*x+1</pre></td>
<td>     y was not 0</td>
<td><pre>x = 124, y = 1</pre></td>
<td>     82
<br />   41</td>
</tr>    

<tr><td><pre>   print(x)</pre></td>
<td>It was the next line</td>
<td><pre>x = 124, y = 1</pre></td>
<td>82<br />
41<br />
124</td></tr>
</table>

And so on.
</text>
      
    </section>
    <section>
      <title>Python language summary</title>
      <text>
	<p>We now present a brief summary of all of Python as we'll
	use it in this chapter.  This includes a specification of the
	syntax--the rules that define what is allowed as Python code,
	and the semantics--what the various valid constructs do.  </p>

	<p>The way this specification works is recursive: For example,
	we will first specify that Python code is run one line at a
	time.  So to do something in Python, we have to write a
	sequence of lines.  So then the question is: What is a line?
	In the table below, we see that a line is either an
	'assignment line', 'print line', or a 'flow-control' line.  </p>

	<p>We haven't said what any of these are yet, but behold, they
	show up later in the table!  The table tells us that
	assignment lines are used for computation and for setting
	variables, print lines are for printing things, and
	flow-control lines are for deciding which line to execute
	next.  </p>

	<p>So if we now decide that what we want is to store some
	number in a variable, then we look at the specification for an
	assignment line, since that seems the thing for the job.  It
	says that an assignment line looks like: 

	<pre><i>variable name</i> = <i>expression</i></pre>

	We haven't said what variable names or expressions are, but
	they are also described in the table!</p>

	<p>Looking further down to variable names, we see that a
	variable name can be anything with letters, numbers, and
	underscores, but not starting with a number, and not a Python
	keyword.  So we can decide to call our variable, say, 
	<pre>H3LL0_th3re_</pre>.  </p>

	<p>But what about the expression bit?  Expressions are defined
	in the table as any valid combination of numbers, strings, and
	variables using the basic operations and parentheses for
	grouping.  So if we want to store the value 89*90, we can do
	this like: 

	<pre>H3LL0_th3re_ = 89*90</pre>

	And the fact that we have followed the table tells us that
	this is a valid assignment line which will store the value of
	the expression 89*90--i.e. the number 8010--into a variable
	called H3LL0_th3re_.</p>

	<p>We will discuss each element in greater detail in the next
	section, but place the whole thing in brief here as a
	reference: </p>

	<div ng-include="'sim/py/ref.html'">
	</div>
      </text>
      
    </section>
  </section>

  <section>
    <title>A detailed explanation of Python</title>
    <summary>The above table represents nearly all of the features of
    Python that we shall use in this chapter.  However the table
    doesn't explain how to think about or when to use these in
    practice.  This section will get more into that, as well as a
    small number of odds and ends that don't come up often and so were
    left out of the reference table.</summary>
    <text>
      <p>We now give a more detailed explanation of the Python
      language elements we introduced above.  For example, in addition
      to providing greater detail about what they are, we provide
      examples and give examples of when to use them.   
      </p>
    </text>
    <section>
      <title>Python syntax</title>
      <summary>We summarize the syntax again, but this time in a form
      that is amenable to mechanically walking through a program and
      confirming that it follows all the rules: The syntax tree.</summary>
      <text>
	<p>Before we dive too deep into explaining Python, we
	reiterate that while the most interesting part of any
	programming task is always deciding how to match the code to
	the problem, your code must first always conform to proper
	Python syntax or it will not do anything at all.  Happily,
	ensuring proper syntax in your Python is very much the easy
	part, and doesn't even require you to think about or even know
	what your code does.  Much as you can probably tell that the
	phrase "Begone, you ancephalous lummox!" is valid English,
	whereas "Accismus very kerfuffle the, bromnopea in" is not,
	even without knowing the meaning of many of the words
	involved, you do not need to understand Python semantics in
	order to tackle its syntax.</p>

	<p><def term="syntax tree">To better understand the syntax, we
	will introduce another way of visualizing it, called a
	<b>syntax tree</b>.  This is a visualization that highlights
	the relationships between the syntax elements.</def>   The
	most fundamental syntax element is a line of code: The program is
	entirely comprised of lines.  But what is a line allowed to
	be?  Well, there are three choices: Assignment lines, print
	lines, and flow-control lines.  </p>

	<figure><caption>The start of the Python syntax tree</caption></figure>

	<p>But the description of the assignment lines includes some
	further terminology that needs to be explained: What is a
	variable name?  What is an expression?  And for flow-control
	lines, what is a test?  So to complete the syntax tree, we
	extend it with the descriptions of these things as well, taken
	from the table: </p>

	<figure><caption>The full syntax tree for Python</caption></figure>

	<p>To see how this works, let us take an example program:</p>

	<python>x = 2
if(x &lt; 2):
   print("Hi")
if(x >= 2):
   print("Bye")
x = 5 + x</python>

        <p>First of all, of course this consists of lines.  But
	further, each line is one of the three types of line:</p>

	<figure width="500px"><caption>Lines of the program colored by type</caption></figure>

	<p>And further, for e.g. x = 5 + x to be a valid assignment,
	the first thing must be a valid variable name.  "x" indeed
	satisfies all the rules, so this is OK.  Then there must be an
	"=", which there is.  Finally, there must appear a valid
	expression.  "5+x" is a combination of a variable and a number
	using the "+" operator, so indeed qualifies as a valid
	expression.  We can perform this analysis with the rest of the
	program, colorizing each syntax element according to its
	type, and we get: </p>
	
	<figure width="500px"><caption>Lines of the program, with sub-elements
	colorized by type.</caption></figure>

	<p>We can also play this game with our example program from
	the previous section: </p>

<python>x = 27
while(x != 1):
   y = x % 2
   if(y == 0):
      x = x / 2
   else:
      x = 3 * x + 1
   print(x)
print("Done!")</python>

<p>and check line-by-line that it is a valid program: </p>

<code>x = 27 </code>

<p>This first line looks like it must be an assignment.  That means it has to look like </p>

<code><i>variable name</i> = <i>expression</i></code>

<p>Indeed, looking at the rules for variable names, "x" is a valid
variable name.  Further, expressions are defined as numbers, strings,
variables, or combinations thereof.  27 is a number, and hence a valid
expression.  So indeed, this is a valid assignment line.</p>
      
<code>while(x != 1):</code>

<p>This is a while line, so it must look like</p>

<code>while(<i>test</i>): </code>

<p>So we need to check that <pre>x != 1</pre> is a valid test.  A test
has to look like:</p>

<code><i>expression</i> <i>comparison</i> <i>expression</i></code>

<p>and since x is a valid expression (it is a variable name), != is a
valid comparison (as we can see from our list of comparisons), and 1
is a valid expression (it is a number), and since this line is
followed by some indented lines, it is a valid while flow-control
line.</p>

<code>   y = x % 2</code>

<p>This line is indented as it is part of the while loop.  It looks
like an assignment, and indeed, y is a variable name, and x % 2, being
a combination of a variable name (x) and a number (2) using one of the
allowed operators (%), is an expression.  </p>

<code>   if(y == 0):</code>

<p>Much like we checked the while line, this is a valid "if" flow-control line.  In fact, since it has an "else" later, these form a valid if/else flow-control structure: </p>

<code>
   if(y == 0):
      x = x / 2
   else:
      x = 3 * x + 1
</code>

<p>Note that the line following the "if" line is indented by two steps.
The if line is indented once because it is inside the while loop.
Then remember that lines under the if statement have to be indented
not just "three spaces" full stop, but three spaces more than the if
line they are following.  The effect is that the line</p>

<code>      x = x / 2</code>

<p>gets indented using 6 spaces, since it is inside the if, which is inside a while.  </p>

<code>   print(x)</code>

<p>This is a print statement, i.e. something like </p>

<code>print(<i>expression</i>)</code>

<p>and is indeed valid, since x, being a variable name, is a valid expression</p>

<code>print("Done!")</code>

<p>This is another valid print line, since "Done!" is a valid string, and strings are valid expressions.  </p>

<p>So we've checked that this program is syntactically valid.  One
final thing to point out about this syntax-checking procedure was its
mechanical, recursive nature: Once we identify that, say, the line</p>

<code>x = 3 * x + 1</code>

<p>is an assignment, that means it has to be constructed from a variable
name and an expression.  So we identify the pieces of the line that
should correspond to each of these: x is the variable name, and 3 * x
+ 1 should be the expression.  Then we check the definitions of each
of these: A variable name is any combination of letters, numbers, and
underscores, with certain exceptions.  x is thus a valid variable
name.  Now we check 3 * x + 1 is a valid expression similarly just by
going back to the definition of "expression" in the syntax.</p>


<aside><p>The fact that our specification of the syntax leads
naturally to a mechanical checking procedure is important.  Since
ultimately, there has to be a program that understands the programming
language in order to turn it into ISA operations, it is natural that
this program be able to take such a specification and follow an
algorithm that generalizes our checking procedure.  In your future
computer science studies, you may take a course in designing your own
programming language, where you will make all this precise and
effectual.  </p></aside>

      </text>
    </section>
    <section>
      <title>Assignments</title>
      <summary>Assignments are <i>variable_name</i>=<i>expression</i>.
      The assignment line will evaluate the expression and store the
      result in the variable named on the left side of the "=".
      </summary>
      <text>
<p>Recall that assignments are written 

<code><i>variable name</i> = <i>expression</i></code>

These are how we store and modify the values in variables.  For
instance, the line</p>

<code>x = 2</code>

<p>stores the value 2 in a variable called x.  Then if we later want to use this stored value, we can refer to it by its name, x.  For instance, </p>

<code>y = 2 * x</code>

<p>will store the value 4 into another slot called y.  We've seen a couple of slightly trickier variants of this already.  For example, we can update variables using themselves: </p>

<python>x = 2
x = 7 * x
x = 3 * x + x</python>

<p>In the first line, x is set to 2.  Then in the second line, x is
set to 7*x.  To figure out what this stores in x, Python looks up what
was already stored in x.  It finds 2 was stored there, so it
multiplies this by 7 as requested, and stores the new value of 14 into
x.  The last line then sets x to 56 (convince yourself, if you are
unsure of why.)  </p>

<p>Assignment statements allow us to store the results of a
computation.  So suppose we wish to multiply x by 2 using the
multiplication operator *.  We might naively write the code:

<code>2 * x</code>

This is a valid expression, but we note from our syntax tree that an
expression is not one of the three valid kinds of lines of code!
However, we do have valid lines like print lines which can print the
value of an expression, or assignment lines, which can store the value
of an expression.  So if you want to multiply x by 2, you have to
store the result somewhere, and so you would use an assignment line.
Either you would create a new variable, maybe called y, and store the
value there:

<code>y = 2 * x</code>

or you might overwrite the old value of x with this new value: 

<code>x = 2 * x</code></p>

      </text>
      
      <section>
	<title>Variable names</title>
	<summary>Variable names satisfy the usual rules, but they also
	cannot be any names reserved by Python, like "if" or "while".
	They are also case-sensitive, and in any complicated code at
	all, they should be given sensible names that indicate their
	purpose.</summary>
	
	<text>
<p>We've already specified in the syntax discussion what valid
variable names are, but there are a few further points to make: </p>

<p>Remember we said variable names cannot be words that Python treats
as special?  While you're not terribly likely to use them by accident,
it is good to have a complete list handy of what these all are.  So
here you go: </p>

<code>
and           if	    
as	      import	    
assert	      in	    
break	      is	    
class	      lambda	    
continue      not	    
def	      or	    
del	      pass	    
elif	      print	    
else	      raise	    
except	      return	    
exec	      try	    
finally	      while	    
for	      with	    
from	      yield
global</code>

<p>The reason for this is relatively straightforward: If you named a
variable "if", then when the Python compiler gets to a line like</p>

<code>if = 2</code>

<p>The first thing it sees is "if".  So it might decide that this is in
fact a flow-control line of the "if" sort.  But then none of the rest
of the line makes sense.  In this example it could recover and
unambiguously realize that this must be an assignment, but other
examples using more complicated language features will not permit
disambiguation, and so these names are simply forbidden.
</p>

<p>Another possible gotcha is that variable names are case-sensitive: </p>

<code>banana = 2
Banana = 3</code>

<p>will create two completely different variables that can be used
independently.  Likewise, </p>

<code>x = 3
y = 3*X</code>

<p>Will cause an error, since the second assignment tries to use the
variable called X.  We just created a variable called x, but that is
unrelated to the completely different variable called X.  </p>

<p>Finally, even though x, y, z etc. are valid variable names, and
using one-letter names will save on typing, there is a balance between
brevity and perspicuity to be struck: Imagine you're reading someone
else's code and you come upon a line like: </p>

<code>a = mass * radius * radius * roll_rate * roll_rate / 5 + mass * velocity * velocity / 2</code>

<p>You'd say--great, you're doing some physics.  You've got some
object with mass, radius, velocity, rolling, and you've stored these
quantities in sensibly named variables called mass, radius, roll_date,
and velocity, and you're doing some massive computation involving all
of these, and you're storing it in some variable called a.  That's all
nice, but what the heck is this thing you're computing supposed to
mean?  How much more obvious is this:</p>

<code><font size="2pt">rolling_sphere_kinetic_energy = mass * radius * radius * roll_rate * roll_rate / 5 + mass * velocity * velocity / 2</font></code>

<p>Obviously that could end up being a lot of typing to use this
variable repeatedly in the future, but it's worth thinking about.
Even KE would be a better name here than just a. </p>

<p>Beyond just making the names meaningful, there are differing
conventions found in the wild regarding naming.  In this book, if a
variable name is supposed to be a sequence of words (like above, when
we wanted to name a variable as 'rolling sphere kinetic energy'), we
will have all the words be lower-case and separated by underscores
(since spaces are not allowed in variable names).  

<def term='camel-casing'>There is another convention that some people
use, which is to have nothing separate the words but to capitalize the
first letter of each word, as in
<code>RollingSphereKineticEnergy</code>

This is called

<b>camel-casing</b>.</def></p>
	</text>
	
      </section>
      <section>
	<title>Expressions</title>
	<summary> Expressions are the usual things, but they have to
	make sense: No adding a string to a number or dividing a
	number by 0.  When the program gets to an expression, it will
	evaluate it by plugging in the current values of all variable
	names used in the expression and performing the computation.
	</summary>
	
	<text>
<p>The right hand side of an assignment also bears a little more
discussion: expressions.  We said that an expression was any variable
name, number, string, or valid combination thereof using arithmetic
operations.  </p>

<p>Any expression has a <b>value</b>which is what is stored in the
variable during an assignment.  For example, 

<code>x = 2 * 3</code>

stores 6 into x because the value of the expression <pre>2 * 3</pre>
is 6.  The process of determining the value of an expression is called
<b>evaluation</b>, and happens as follows: 

<ul>
  <li>First, find any variable names in the expression and substitute
  in place of those variable names the values currently stored in the
  corresponding variables.  If any of the variables has no stored
  value, give a runtime error.</li>
  <li>Then perform the operations specified in the expressions in the
  with the usual order of operations: 
  <ul>
    <li>Anything in parentheses gets evaluated first</li>
    <li>Any multiplication or division or modulus operations get
    performed left-to-right.  </li>
    <li>Then finally any addition and subtraction happen last.</li>
  </ul>
  If any operation has invalid inputs--e.g. division by zero, or
  attempting to multiply things that are not numbers, give a runtime
  error.
  </li>
</ul>

We can use this to determine what gets stored in x in the following case:

<python>x = 4
y = x + 1
x = 2
x = 5*x + 2*(3 - y)</python>

The first assignment sets x to 4.  The second one sets y to whatever
is the value of x + 1.  To evaluate this expression, we plug in the
current value of x (namely 4) in place of the name 'x' in this
expression, yielding 4 + 1, and then we perform the arithmetic to get
a value of 5.  So the second assignment assigns the value 5 to y.  The
third assignment stores the value 2 in x.</p>

<p>Finally, to find out what the last assignment stores in x, we need
to evaluate the last expression

<code>5*x + 2*(3 - y)</code>

To do this, we again plug in the current values of x and y in place of
their names: x is currently 2, and y is currently 5, so we get: 

<code>5*2 + 2*(3 - 5)</code>

Then we're back to a normal grade-school problem, whose answer is 10 -
4 = 6.  </p>

<p>In addition to numbers, expressions are also allowed to use strings.
For instance: 

<code>"Hello world!"</code>

is a valid expression, and hence 

<code>s = "Hello world!"</code>

is a valid assignment.  The only caveat is that arithmetic operations
and strings rarely make sense.  For example, adding a number to a
string isn't OK, so 

<code>"Hello" + 2</code>

is not a valid expression and will create a runtime error.  Likewise, 

<code>"hello" * "aerodrome"</code>

is not a valid expression and will similarly elicit an error.  </p>

<p>We can, however, add two strings: 

<code>"hello" + "world"</code>

is a valid expression, and its value is the 

<def term='concatenation'><b>concatenation</b> (i.e. sticking the two
strings together to make one long string) of the two strings</def>:
'helloworld'</p>

<p>So consider the following examples: </p>

<python>x = Hello world!
y = z+1
z = 3+&quot;hello&quot;</python>

<p>The variable names on the left sides are fine, but all three
expressions are invalid.  The first one looks like it is meant to be a
string, but because it is not enclosed in quotation marks, Python
doesn't realize this and instead tries to interpret it as variable
names.  But variable names cannot contain spaces or !s, so this falls
flat too, and Python gives up an error.  </p>

<p>The second looks valid--it is a combination of a variable name and a number using the operator +.  But we never defined a value for z!  So Python will try to store the value of this expression in y.  To do this, it will look up what we stored in z and try to add 1 to it.  And this will fail, because we never stored anything at all in z.  </p>

<p>The third example contravenes the weasel-word in the syntax
definition: We required only &quot;valid&quot; combinations of
variables, numbers, and strings.  Obviously adding two numbers is a
&quot;valid&quot; combination, but exactly what else counts?
Certainly almost any arithmetic operation should work on any numbers
or variables that store numbers.  For instance, </p>

<code>x = 1+1
y = 78/x</code>

<p>As mentioned, division (namely, / and %) when the right operand is
0 will cause an error, since as in mathematics generally, dividing by
zero does not make sense to a computer: </p>

<python>x = 4
y = x/2-2
z = x % y</python>

<p>Further, if you try to operate on a number and a string, this is not going to go well: </p>
<python>x = &quot;hello&quot;
y = 89/x</python>
</text>
      </section>
      <section>
	<title>Strings</title>
	<summary>Strings are anything enclosed in quotation marks.  To
	include a quotation mark inside a string, escape
	it--i.e. precede it by a backslash.  To insert a line-break
	into a string, escape the letter n.  To insert an actual
	backslash into a string, just escape a single backslash with a
	second one.</summary>
	<text>
<p>Recall we defined a string as any sequence of characters contained
inside quotation-marks.  It is a type of expression whose value is the
text inside the quotes.  But what if we change that text to itself
contain a quote?  For instance, </p>

<pre>print(&quot;hi&quot;)</pre>

<p>prints: </p>

<code>hi</code>

<p>But what if we want to print the following: </p>

<code>&quot;hi&quot;, he said</code>

<p>We might try </p>

<python>print(&quot;&quot;hi&quot;, he said&quot;)</python>

<p>But Python understands this as three things: </p>

<p>The string &quot;&quot;, which contains no text, followed by the
variable called hi (since this is outside any quotes, so is not a part
of the string), followed by the string &quot;, he said&quot;.
Disaster follows. </p>

<p>To include a quote, then, you need to <def term='escape'><b>escape</b>
it--that is, you precede it in the string with a backslash</def>.  In
general, backslash is the string escape character, meaning that
whatever character comes after it doesn't have its usual meaning, but
has some special meaning.  The usual meaning of ' is 'this is the
boundary of a string', but if we precede it with a backslash, then its
meaning just becomes just 'the single-quote character'.  So </p>

<pre>print(&quot;\&quot;hi\&quot;, he said&quot;)</pre>

<p>accomplishes the desired result.  Similarly, if we want to store a
string that contains multiple lines, like the string</p>

<code>XXO
_O_
OX_</code>

<p>which might represent a tic-tac-toe board in a game we're programming.  </p>

<p><def term='newline'>It turns out that if we escape the character n,
when escaped, has the special meaning of `the <b>newline</b>
character'--that is, a character which represents going to another
line.  </def> Thus </p>

<code>print(&quot;XXO\n_O_\nOX_&quot;)</code>

<p>prints the above.  </p>
	</text>
	
      </section>

    </section>
    <section>
      <title>Print</title>
      <summary>Print lines evaluate the provided expression and output
      the value to the screen.  We can put print statements at various
      places through our program to get an idea of what it's
      doing.</summary>
      <text>
<p>Now that we know what expressions are, print is reasonably
straightforward: it simply prints to the screen the value of the
expression it is given: </p>

<python>print("hello")
x = 4
y = "blah"
print(x*2/5)
print(y+"zzzzz")</python>

<p>prints</p>

<code>hello
1.6
blahzzzzz</code>

<p>We can use it to print the value stored in a variable</p>

<python>print("Hello")
x = 2
print(x-3)
print(x)</python>

<p>A common use-case for print beyond just printing a final answer is
debugging: if we have a program that is misbehaving and we want to get
some idea of what is happening, we can insert a print statement in the
middle.  For instance, suppose we accidentally wrote our 3x+1 program
thus:
</p>

<python>x = 27
while(x != 1):
   y = x / 2
   if(y == 0):
      x = x / 2
   else:
      x = 3 * x + 1
   print(x)
print("Done!")</python>

<p>Then we would see printed </p>

<code>27
82
247
...</code>

<p>and more numbers that would keep growing forever.  </p>

<p>If we wanted to know what was happening in more detail, we could think: y is supposed to be either 0 or 1, telling us whether x was even or odd.  So let us confirm that this is happening by printing y during the loop as well: </p>

<python>x = 27
while(x != 1):
   y = x / 2
   if(y == 0):
      x = x / 2
   else:
      x = 3 * x + 1
   print(y)
   print(x)
print("Done!")</python>

<p>And we see printed </p>

<code>13.5
82
41.0
247
123.5
742
371.0
2227
1113.5
6682
3341.0
20047
10023.5
60142
...</code>

<p>So something has gone wonky, since we shouldn't be seeing any decimals in the procedure run normally.  To make it even more clear, we'll add in some more print statements to show us which numbers being printed were x and which were y: </p>

<python>x = 27
while(x != 1):
   y = x / 2
   if(y == 0):
      x = x / 2
   else:
      x = 3 * x + 1
   print("here is y: ")
   print(y)
   print("behold x: ")
   print(x)
print("Done!")</python>

<p>Giving: </p>

<code>here is y: 
13.5
behold x: 
82
here is y: 
41.0
behold x: 
247
here is y: 
123.5
behold x: 
742
here is y: 
371.0
behold x: 
2227
here is y: 
1113.5
behold x: 
6682</code>

<p>So we see that instead of being 0 or 1, y is just being set to some crazy, often decimal values.  So which line could possibly be wrong except the line that assigns a value to y?  </p>

<p>So we see that </p>

<code>   y = x / 2</code>

<p>should have been </p>

<code>   y = x % 2</code>

<p>and then all is well.  </p>

      </text>
      
    </section>
    <section>
      <title>Flow control</title>
      <summary>Flow control lines determine what line gets executed
      next.  A flow control line can either be an if/else pair or a
      while loop.</summary>
      <text>
	<p>Flow-control lines are lines that control the order in which
	the lines following it get executed.  The two kinds of
	flow-control we introduce here are if/else lines and while
	lines:</p>
      </text>
      <section>
	<title>if/else</title>
	<summary>"if" lines look like if(<i>test</i>): and are used to
	choose between two choices of sets of lines to run.  The lines
	following an "if" line, which should be run only if the test
	in the "if" line is true, must all be indented--that is, they
	should start with three more spaces than the "if" line does.
	"if" lines are sometimes paired with an "else" line, which is
	written simply as else:  The lines following an "else"
	line, which will be run only if the test is false, should also
	be indented with three more spaces than the "else"
	line.</summary>
	
	<text>
<p>The if statement exists for the following use-case: Imagine we're
writing a search engine, and we have a variable that stores the word
the user is searching for.  It might have come from one of two files:
poems.txt or raps.txt, and we need to determine which.  (It's a very
simple search engine for now).  To display the answer, we'll have to
have both the line</p>

<code>print(&quot;poems.txt&quot;) </code>

<p>and the line</p>

<code>print(&quot;raps.txt&quot;)</code>

<p>somewhere in our code.  But we definitely don't want both of them
to run--we only ever want at most one to run, but which one we want
depends on which file the word was found in.  Choosing what code to
run depending on some condition is exactly the job of the if
statement.  </p>

<p>If you recall, an if/else statement is: </p>

<code>if(<i>test</i>): 
   indented lines
else: 
   indented lines</code>

<p>and it runs the first set of indented lines if the test succeeds,
and the second set if the test fails.</p>

<p>So if we can contrive a test that will tell us whether the
searched-for word is in poems.txt or raps.txt, we'll be set: We can
then put the first print statement 

<code>print(&quot;poems.txt&quot;)</code>

in the first set of indented lines, and the second print statement: 

<code>print(&quot;raps.txt&quot;)</code>

in the second set.  </p>

<p>But these are supposed to go in as <i>indented</i> lines, so we return
to our syntax tree to recall what this means: They have to be
preceded with three spaces more than the previous line.  There were
no spaces at the beginning of the if line, so to indent the print
lines, we given them three spaces at the beginning, like so: 

<code>if(<i>test</i>): 
   print(&quot;poems.txt&quot;)
else: 
   print(&quot;raps.txt&quot;)</code>

(We still don't know what the test is supposed to be, but we'll
discuss that later.)</p>

<p>For if statements in general, the semantic meaning of the
indentation makes it very important, and often a source of subtle
bugs: </p>

<python>x = 2
if(x == 2): 
   print(&quot;x is two&quot;)
else:
   print(&quot;x is not two&quot;)
print(&quot;potato&quot;)</python>

<p>outputs</p>

<code>x is two
potato</code>

<p>whereas </p>

<python>x = 2
if(x == 2): 
   print(&quot;x is two&quot;)
else:
   print(&quot;x is not two&quot;)
   print(&quot;potato&quot;)</python>

<p>outputs only</p>

<code>x is two</code>

<p>because the line </p>

<code>print(&quot;potato&quot;)</code>

<p>is indented, which puts it in the block of lines that only get
executed if the test fails.  And since the test is testing whether x
is equal to 2, the test does not fail.  </p>

	</text>
      </section>
      <section>
	<title>tests</title>
	<summary>Now we need to know what kinds of tests we can use
	inside an "if" line.  They are simply two expressions
	separated by a comparison operator, which can test whether the
	two expressions are equal, or whether, say, one is larger than
	the other.</summary>
	<text>
<p>So what kinds of tests can we use in if lines?  The syntax tree
tells us that they have to look like 

<code><i>expression</i> <i>comparison</i> <i>expression</i></code>

We already know what expressions are, and our syntax tree tells us
that comparisons are any of: 

<code>&lt;, &gt;, &lt;=, &gt;=, ==, !=</code>

which have the following meanings: 

<table>
<tr><td>Comparison operator</td><td>Meaning</td></tr>
<tr><td>&lt;</td><td>Less than</td></tr>
<tr><td>&gt;</td><td>Greater than</td></tr>
<tr><td>&lt;=</td><td>Less than or equal to</td></tr>
<tr><td>&gt;=</td><td>Greater than or equal to</td></tr>
<tr><td>==</td><td>Equal to</td></tr>
<tr><td>!=</td><td>Not equal to</td></tr>
</table>
</p>

<p>On either side of the comparison operator can be an expression.
The test is said to <def term='succeed (tests)'><b>succeed</b> or to
<b>evaluate to true</b> if the values of the two expressions do in
fact compare in the way that the comparison operator dictates</def>.
<def term='fail (tests)'>If they do not, then the test is said to
<b>fail</b> or to <b>evaluate to false</b></def>.</p>

<p>So for example, we can test if 2*x is greater than 5 with the test: </p>

<code>2*x > 5</code>

<p>We can test if the variable x stores the string &quot;hello&quot; with </p>

<code>x == &quot;hello&quot;</code>

<p>If we have three variables x, y, and z, which all store numbers, and we want to print something if x + y is not the same as z, we can do: </p>

<code>if(x+y != z):
   print(&quot;something&quot;)
</code>

<p>One final dumb example is </p>

<code>if(1 == 1): print(&quot;hello&quot;) else: print(&quot;something
is wrong with the universe&quot;)</code>

<p>This is indeed a valid test: Numbers are valid expressions, and ==
is a valid comparison, so 1 == 1 is a valid test.  But it should
always succeed (unless something goes wrong with the universe), so the
above program should be just a very complicated way of writing the
entirely equivalent code: </p>

<code>print(&quot;hello&quot;)</code>

	</text>
      </section>
      <section>
	<title>while</title>
	<summary>"while" lines look like while(<i>test</i>): and are
	used to get a set of lines to run repeatedly.  The lines
	following the "while" line that you want to run over and over
	until the test in the "while" line is no longer true should
	all be indented three spaces further than the "while"
	line.</summary>
	<text>
<p>Finally, we get to the last flow-control statement that we'll talk about here, namely while.  While is how you get a block of lines repeated several times: </p>

<code>while(test): 
   lines that you want to run for as long as the test holds true
   (the test is re-run every time we get to the end of the indented lines)</code>

<p>This comes in handy when, as an example, we want to print 20 smiley faces followed by a smirk.  We could use 21 print statements: </p>

<python>print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":/")</python>

<p>However if we wanted to print 100 smileys, our program would get rather long, and it may be harder to ensure we got exactly 100 print statements in there.  To simplify this dramatically, we can instead use a while statement.  This requires some thought, however: The while statement will repeat the indented block as long as the test is true.  So clearly we want the print line to be in the indented block: </p>

<code>while(something):
   print(&quot;:)&quot;)
print(&quot;:/&quot;)</code>

<p>But what should the something be?  We want the indented block to repeat 20 times, so the something should be a test that is true the first 20 times it is run, but not the 21st time.  One way to accomplish this is to have a counter variable that counts how many times the indented block has been run.  When the program starts, we'll set the counter to 0: </p>

<code>counter = 0
while(something): 
	print(&quot;:)&quot;)
print(&quot;:/&quot;)</code>

<p>Except now, each time the block is run, we want the counter to increase by 1.  An assignment that can increase the counter by 1 is: </p>

<code>counter = counter + 1</code>

<p>so if we put this inside the indented block, it will be run each time the indented block is run: </p>

<code>counter = 0
while(something): 
	print(&quot;:)&quot;)
	counter = counter + 1
print(&quot;:/&quot;)</code>

<p>Now finally, what should the something be?  The first time the while block is run, counter will start as 0 and get updated to 1.  The second time, it will start as 1 and be updated to 2.  The third time, the counter will start as 2 and be updated to 3 during the execution of the block.  So if the something is </p>

<code>counter &lt; 3</code>

<p>then after the third run of the block, counter will be 3, so the test will fail, and the block will not be repeated a fourth time, and the line will proceed to the line </p>

<code>print(&quot;:/&quot;)</code>

<p>Thus if we wanted to print three smileys and then a smirk, we would do: </p>

<python>counter = 0
while(counter &lt; 3): 
   print(":)")
   counter = counter + 1
print(":/")</python>

<p>We can double-check our understanding of what happens by single-stepping this program: </p>

<table>
<tr>
<td>Current line</td>
<td>Why we went to this line</td>
<td>Variables after current line runs</td>
<td>Output so far</td>
</tr>

<tr>
<td>counter = 0</td>
<td>It was the next line</td>
<td>counter = 0</td>
<td></td>
</tr>

<tr>
<td>while(counter &lt; 3): </td>
<td>It was the next line</td>
<td>counter = 0</td>
<td>
</td>
</tr>

<tr><td>   print(&quot;:)&quot;)</td>
<td>counter was &lt; 3</td>
<td>counter = 0</td>
<td>:)</td></tr>

<tr>
<td>   counter = counter + 1</td>
<td>It was the next line</td>
<td>counter = 1</td>
<td>:)</td>
</tr>

<tr>
<td>   print(&quot;:)&quot;)</td>
<td>We reached the end of the while block, but counter was &lt; 3, so we go back to the start</td>
<td>counter = 1</td>
<td>:)
:)</td>
</tr>

<tr>
<td>   counter = counter + 1</td>
<td>It was the next line</td>
<td>counter = 2</td>
<td>:)
:)</td>
</tr>

<tr>
<td>   print(&quot;:)&quot;)</td>
<td>We reached the end of the while block, but counter was &lt; 3, so we go back to the start</td>
<td>counter = 2</td>
<td>:)
:)
:)</td>
</tr>

<tr>
<td>   counter = counter + 1</td>
<td>It was the next line</td>
<td>counter = 3</td>
<td>:)
:)
:)
</td>
</tr>

<tr>
<td>print(&quot;:/&quot;)</td>
<td>counter was not &lt; 3</td>
<td>counter = 3</td>
<td>:)
:)
:)
:/</td>
</tr>
</table>

<p>Thus to accomplish the original goal, we can use the program: </p>

<code>counter = 0
while(counter &lt; 20): 
	print(&quot;:)&quot;)
	counter = counter + 1
print(&quot;:/&quot;)</code>

<p>This pattern of having a counter incrementing by 1 in a while loop is very common, and you should bear it closely in mind for the future, but it is not the only paradigm for while loops.  For example, we can use a while loop to print all the powers of 2 less than a thousand: </p>

<python>x = 1
while(x &lt; 1000):
   print(x)
   x = 2*x
print(&quot;Done&quot;)</python>

<p>If you're not comfortable with why this program accomplishes this goal, single-step it in the same manner as before to see.</p>

<p>Finally, in the spirit of the last dumb if/else example, we also
have a dumb while loop example.  Remember, 1 == 1 is still a valid
test, so </p>

<python>while(1 == 1):
   print(&quot;:)&quot;)</python>

<p>is a valid while loop.  <def term="infinite loop">Since the test is
always true, and the while statement is supposed to repeat the
indented lines for as long as the condition is true, it will print
smileys forever.  This is called an <b>infinite loop</b></def>.  They
can happen intentionally when you're just trying to be infinitely
happy like in the above example, but they are generally a run-time
error (i.e. part of a valid program that provides undesirable
behavior when run), and are not always as obvious as that first
example might lead you to believe.  For instance: </p>

<python>x = 49
while(x*x % 4 != 3):
   x = x + 1
   print(x)
   print(x*x % 4)</python>

<p>Does this program infinite-loop or not?</p>

	</text>
      </section>
      
    </section>
        <section>
	  <title>Comments and whitespace</title>
	  <summary>Python ignores any lines that are blank or
	  otherwise only contain spaces and tabs.  It also ignores
	  anything after a # symbol, so you can use this to insert
	  English comments into your code explaining what it
	  does.</summary>
	  
	  <text>
	    <p><def term="whitespace">As you may have gathered from
	    previous examples that inadvertently included blank lines,
	    python ignores any line that is blank, or any line that
	    includes nothing but spaces or tabs.  Such lines are
	    called <b>whitespace</b> (presumably because the
	    background colors for many text editors is white, and so
	    the blank space is white)</def>.</p>

	    <p><def term="comment">Python will also ignore anything
	    after a '#' character on any line.  Text preceded by a
	    '#' can therefore be used to annotate the program,
	    explaining what it does inline.  These pieces of
	    explanatory text are called <b>comments</b>.</def></p>

	    <p>Both commenting and the judicious use of whitespace can
	    help someone reading the code to better understand what's
	    going on (or at least, what the programmer meant to
	    happen).  For an example, we comment our original 3x+1
	    program and give it a little whitespace to help separate
	    the different steps</p>

	    <code>x = 27
# Repeat the procedure as long as x isn't 1
while(x != 1):

   # To test whether x is even or odd, we store x % 2 in the variable y
   y = x % 2
   
   if(y == 0):
      # If y is 0, then x was even; divide it by two!
      x = x / 2
      
   else:
      # If y wasn't 0, then x was odd; 3x+1 it!
      x = 3 * x + 1
      
   print(x)
      
# If we got here, then the while loop is over and we can declare victory!
print("Done")</code>
	    
	  </text>
	</section>
  </section>

  <section>
    <title>Simple examples</title>
    <text>
      <p>Now we set about writing some simple programs.  As discussed
      in chapter 1 and reflected in the structure of this chapter,
      this happens in two stages: turning the problem into a
      computer-friendly but still human-readable algorithm, and then
      writing that algorithm in a computer-friendly language, namely
      Python.</p>

      <p>That is the theory, at least.  In practice, the first
      algorithm we think of won't always do the trick quite correctly,
      or even if it does, the first program we write may not implement
      that algorithm correctly.  This is normal, and easily remains
      true of all computer programming regardless of level of
      experience.  So in these examples, many of our first attempts
      may include some error, or may be inefficient or scale poorly.
      In these case, we will include further steps for debugging or
      optimizing, where we go back, identify the source of the
      problem, and try to fix it.</p>
    </text>

      <section>
	<title>Factorial</title>
	<summary><p>To write a program that computes factorials (10
	factorial is 10*9*8*7*6*5*4*3*2*1, e.g.) we use the idea of a
	while loop with a counter, but we keep another variable that
	will eventually store the answer that we multiply by the
	counter each time we go through the loop.</p>

	<p>There is some subtlety in getting exactly the right answer
	and not going through the loop one too many or one to few
	times.</p></summary>
	<text>
	  <p><b>Introduction: </b></p>

	  <p>The factorial is a mathematical operator that takes in a
	  single positive integer (1, 2, 3, ...) and outputs the
	  product of all the positive integers at or below the input.
	  The factorial of 5 is written as &quot;5!&quot;.  So 5! =
	  5*4*3*2*1 = 120, and 10! = 10*9*8*7*6*5*4*3*2*1 = 3628800.
	  In this example, we wish to write a program that will
	  compute the actual value of 10!.</p>

	  <p><b>Algorithm: </b></p>
	  
	  <p>The definition above is completely unambiguous, and
	  explains perfectly well to a human how to compute
	  factorials.  However we just saw all the things we can tell
	  a computer how to do, namely assignment, print, if, if/else,
	  and while.  You'll note that "multiply the integers 1
	  through 10" is not on that list, so we need to find a way of
	  telling the computer how to compute 10! using these simple
	  operations.</p>

	  <p>Well, this is easy: Clearly we want to print the product
	  1*2*3*...*27.  If we reference our chart above, we see that
	  we are allowed to print any expression.  But what was an
	  expression?  It was any number, string, variable, or
	  combination thereof using operations +, -, *, /, %.  Aha!
	  So 1*2*3*4*5 is an expression--it is a combination of
	  numbers using the operation *.  Therefore: </p>

	  <p><b>Program: </b></p>

	  <python>print(1*2*3*4*5*6*7*8*9*10)</python>

          <p><b>Debrief: </b></p>

	  <p>That was all very good, except now say I want to know
	  what is 27!  Now I have to make non-trivial and tedious
	  changes to the program--in fact, it is basically the same
	  work as doing this on a calculator by hand!  In short, we
	  have a problem of scalability--this program cannot compute
	  larger factorials without us doing a large amount of work
	  also to change it.  What we would like is a program that
	  looks like:</p>

<code>input = 10
... some things
... some more things
print(answer)</code>


<p>That is, the program starts by storing the desired input value in a
variable, and then whatever that value is, it does some computation
and eventually ends up with the factorial of this initial value stored
in the variable called answer.</p>

<p>This way, if we decide later that we instead wanted 27!, we can just change the first line to 

<code>input = 27</code>

and leave the rest of the program untouched, and still get the correct answer.  </p>

<p><b>Algorithm, Mark II: </b></p>

<p>The above desired form of the program tells us the first and last steps of the algorithm: </p>

<code>Step 1: Store the number whose factorial we want in a variable called input.  
...
Step last: print the number stored in the variable answer.  
</code>

<p>So clearly at some point we'll need to make a variable called
answer.  May as well make that step 2.  So step 2 will be an
assignment (a valid operation), setting answer equal to...what?
Clearly we cannot just say <code>answer = input!</code>, since ! is not
one of the operations that Python understands.  So let's just start
small--answer = 1</p>.

<code>Step 1: Store the number whose factorial we want in a variable called input.  
Step 2: Store the number 1 in the variable answer.
...
Step last: print the number stored in the variable answer.  
</code>

<p>Now, clearly what we need to do is to first multiply answer by 2,
and then by 3, and then by 4, and so on until we get to 10.  So let us
store the thing we're multiplying by in yet another variable.  This
variable will be counting up from 2, and will be multiplied into
answer at each step.  So we'll call this variable counter, and since
the first multiplication will be by 2, we'll start this variable at 2.
</p>

<code>Step 1: Store the number whose factorial we want in a variable called input.  
Step 2: Store the number 1 in the variable answer.
Step 3: Store the number 2 in the variable counter.
...
Step last: print the number stored in the variable answer.  </code>


<p>Now we want to increment counter repeatedly until it is 10, or, more precisely, until it matches whatever is in the variable input.  Intuitively this process looks like: 

<code>answer = answer*counter
counter = counter + 1
answer = answer * counter
counter = counter + 1
answer = answer * counter
counter = counter + 1
answer = answer * counter
counter = counter + 1
...</code>

except we want this to stop when counter exceeds input.  </p>
<p>So: 

<code>Step 1: Store the number whose factorial we want in a variable called input.  
Step 2: Store the number 1 in the variable answer.
Step 3: Store the number 2 in the variable counter.
Step 4: Repeat the following until counter is greater than input: 
	Substep 1: Replace answer with answer * counter
	Substep 2: Increment counter by 1
Step 5: print the number stored in the variable answer.  </code>
</p>

<p>And recall that this 'repeat the following' sort of step is
something that we can tell the computer to do--this is what the while
instruction does!  So we do: </p>

<p><b>Program, Mark II: </b></p>

<python>input = 10
answer = 1
counter = 2
while(counter &lt; input): 
   answer = answer * counter
   counter = counter + 1
print(answer)</python>

<p>Let us single-step this program with a slightly smaller input: 4.  So the program should compute 4! = 4*3*2*1 = 24 and print this result.  Let us see: </p>

<table><tr>
<td>Current line</td>
<td>Why we went to this line</td>
<td>Variables after current line runs</td>
<td>Output so far</td>
</tr><tr>
<td>input = 4</td>
<td>It was the next line</td>
<td>input = 4</td>
<td></td>
</tr><tr>
<td>answer = 1</td>
<td>It was the next line</td>
<td>input = 4
answer = 1</td>
<td></td>
</tr><tr>
<td>counter = 2</td>
<td>It was the next line</td>
<td>input = 4
answer = 1
counter = 2</td>
<td></td>
</tr><tr>
<td>while(counter &lt; input):</td>
<td>It was the next line</td>
<td>input = 4
answer = 1
counter = 2</td>
<td></td>
</tr><tr>
<td>answer = answer * counter</td>
<td>counter was less than input</td>
<td>input = 4
answer = 2
counter = 2</td>
<td></td>
</tr><tr>
<td>counter = counter + 1</td>
<td>It was the next line</td>
<td>input = 4
answer = 2
counter = 3</td>
<td></td>
</tr><tr>
<td>answer = answer * counter</td>
<td>We reached the end of the while block, but counter was still less than input, so we go back to the start</td>
<td>input = 4
answer = 6
counter = 3</td>
<td></td>
</tr><tr>
<td>counter = counter + 1</td>
<td>It was the next line</td>
<td>input = 4
answer = 6
counter = 4</td>
<td>
</td>
</tr><tr>
<td>print(answer)</td>
<td>We reached the end of the while block, and counter was not less than input, so we proceed to the next line</td>
<td>input = 4
answer = 6
counter = 4</td>
<td>6</td>
</tr></table>

<p>So something went slightly wrong!  That is, a runtime error has occurred!  </p>

<p>We wanted the last step to be <pre>answer = answer * 4</pre>.  But
counter was set to 4 at the end of the loop body, and then because
counter &lt; input was false (4 is not less than 4), the next iteration
of the loop, which would have done the multiplication by 4, did not
run.</p>

<p><def term="off-by-one error">This is a particularly notorious kind of runtime error called an
<b>off-by-one error</b></def>.  There are a couple of possible fixes.  The simplest
is that we want the loop to run when counter is less than input or
equal to it.  To get this behavior, we replace &lt; by &lt;= to get:

<python>input = 10
answer = 1
counter = 2
while(counter &lt;= input): 
answer = answer * counter
counter = counter + 1
print(answer)
</python>

Another possible fix, the analysis of which is left as an exercise, is the following: 

<python>input = 10
answer = 1
counter = 1
while(counter &lt; input): 
   counter = counter + 1
   answer = answer * counter
print(answer)</python>
</p>

<p><b>Debrief: </b></p>

<p>So finally we have a factorial program that we can easily use to compute larger factorials too: 

<python>input = 50
answer = 1
counter = 2
while(counter &lt;= input): 
   answer = answer * counter
   counter = counter + 1
print(answer)</python>

Later we will learn how to make the program ask for and receive input from the person running the program (as opposed to now, when you have to actually change the program to affect the computation it runs).  Having written the program not using any foreknowledge of the value of the input, it will be easy plug in the code for reading like: 

<code>[get user's input and store its value in the variable input]
answer = 1
counter = 2
while(counter &lt;= input): 
   answer = answer * counter
   counter = counter + 1
print(answer)</code>
</p>
	</text>
      </section>
      <section>
	<title>Primality testing</title>
	<summary>To test if a number is prime, we simply need to take
	all the numbers between that 1 and number (exclusive), and
	check if any of those numbers divides into our number evenly.
	To do this checking, we can use a while loop with a counter,
	and to check whether a number divides evenly into another, we
	can use the modulus operator.  This algorithm is badly
	inefficient, and finding a more efficient one is a hard
	problem.  </summary>
	<text>
	  <p><b>Introduction: </b></p>

	  <p>A prime number is a positive integer that is not evenly
	  divisible by any other positive integer than itself and 1.
	  For instance, 12 is evenly divisible by 4, and therefore is
	  not prime, whereas 13 is prime.  Prime numbers are of
	  interest because every number can be built out of primes: 12
	  is not prime, as it is evenly divisible by 4: 12 = 4*3.  And
	  4 is not prime--it is evenly divisible by 2: 4 = 2*2, so we
	  can break up 12 further: 12 = 2*2*3.  </p>

	  <p>It is sometimes of great interest to determine whether a
	  number is prime.  In this section, we shall write a program
	  capable of doing so.  Specifically, the program shall start
	  with a line like 

	  <pre>n = 101231</pre>

	  and shall, at the end, print either &quot;n is prime&quot; or &quot;n is
	  not prime&quot; depending on the result of its test. </p>

	  <p><b>Algorithm: </b></p>

	  <p>We are given a number, say stored in a variable called n.
	  We want to test if n is prime.  As before, we start with the
	  definition: If it is prime, then no number between 2 and n-1
	  inclusive divides into n evenly.  Thus we can step through
	  these numbers in sequence, as we did with the counter
	  variable in the previous example, and test each one in turn
	  to see if it divides into n evenly.</p>

<code>Step 1: n = 10000001
Step 2: counter = 2
Step 3: Repeat the following as long as counter &lt; n: 
	Substep 1: Test if counter divides into n evenly
	Substep 2: Increment counter</code>

	<p>This seems to cover all the things required by the
	definition of "prime", but it is still quite incomplete: What
	do we do if counter does divide evenly into n?  And for that
	matter, what do we do at the end of the loop?</p>

	<p>In the course of step 3, we'll discover whether or not n was
	prime.  If we store this information somehow, then at the end
	of the loop we can print out the result based on this stored
	information.  To this end, we'll also create a variable called
	is_prime.  We'll start with it set to 1, and if we find a
	divisor, we'll set it to 0.  Then, at the end, we'll test the
	value of is_prime and print as appropriate.  </p>

<code>Step 1: n = 10000001
Step 2: counter = 2
Step 3: is_prime = 1
Step 4: Repeat the following as long as counter &lt; n: 
	Substep 1: Test if counter divides into n evenly.  If it does, set is_prime to 0
	Substep 2: Increment counter
Step 5: If is_prime is 1, print &quot;n is prime&quot;
Step 6: If is_prime is 0, print &quot;n is not prime&quot;</code>

        <p><b>Program:</b></p>

	<p>To turn this into an honest program is reasonably
	straightforward.  The elements we have not yet used are the
	tests, which are accomplished with the if/else instructions.
	How to see if counter divides n evenly?  One way to do it is
	to divide n by counter and see if the quotient is an integer.
	However we don't yet have any operation for testing &quot;is this
	variable an integer&quot;, so that's no good for now.  Another way
	would be to divide n by counter and see if the remainder is 0.
	Recall we can get the remainder of this division with n %
	counter.  So we get:</p>

<python>n = 1000001
counter = 2
is_prime = 1
while(counter &lt; n):
   if(n % counter == 0): 
      is_prime = 0
   counter = counter + 1
if(is_prime == 1):
   print("n is prime")
if(is_prime == 0):
   print("n is not prime")</python>

        <p>This may take quite a few steps.  Remember that you can
        adjust how many steps are taken by the "step" button using the
        input box next to that button.  </p>
   
        <p><b>Debrief: </b></p>

	<p>It is worth noting that the values we chose for the
	variable is_prime--0 to represent that the number is not
	prime, and 1 to represent that it is--were completely
	arbitrary.  We could have started instead by setting is_prime
	to the string "durian", and then in the loop if we found a
	divisor of n, we could change it to the string "penguin goes
	shopping" and get the exact same behavior: </p>

<python>n = 1000001
counter = 2
is_prime = "durian"
while(counter &lt; n):
   if(n % counter == 0): 
      is_prime = "penguin goes shopping"
   counter = counter + 1
if(is_prime == "durian"):
   print("n is prime")
if(is_prime == "penguin goes shopping"):
   print("n is not prime")</python>
   
        <p>The use of 1 and 0 is sort of standard, however, because in
        some sense (which we will discuss later), it takes the least
        amount of space possible to store a variable that is only ever
        1 or 0, whereas if we have to store the strings "durian" and
        "penguin does shopping", this requires more space.  In many
        contexts, therefore, when we have a variable whose value
        represents the truth of some statement, a value of 1
        conventionally represents "true" and a value of 0 represents
        "false".</p>
   
	<p>On the topic of potential improvements, one thing that
	might be nice is for this program to not just tell us that a
	number isn't prime, but also to tell us why the number isn't
	prime--that is, tell us a number that divides evenly into
	it.</p>
	
	<p>This program is also far far less efficient than it could
	be in many ways.  You can probably think of improvements
	already--for instance, we don't have to test all the possible
	divisors counter &lt; n--we can certainly get away with
	testing only to n/2, since if n/2 evenly divides n, then 2
	also evenly divides n, so we would have caught that already.
	Also, none of the numbers between n/2 and n can possibly
	divide evenly into n.  In fact we can get away with fewer than
	that.  </p>

	<p>For a further inefficiency, you should see how long it
	takes to run in tell us that 222 isn't prime, and compare this
	with how many steps you think ought to be needed.  </p>

	<p>The general question of whether this problem had a truly
	efficient solution remained frustratingly unanswered for years
	until an undergraduate project by two students together with
	their adviser at the Indian Institute of Technology found an
	algorithm that they could prove would get the answer quickly
	in all cases.</p>

	</text>
      </section>
      <section>
	<title>Counting digits</title>
	<summary>To count the digits in a number, we repeatedly divide
	it by 10 until it is smaller than 1.  If we keep a counter as
	we do this, then the number of times we divide by 10 will be
	the number of digits in the number (provided we do this
	carefully and avoid off-by-one errors).  </summary>
	<text>
	  <p><b>Introduction: </b></p><p>Starting with some number,
	  count how many digits are required to write the number
	  down.  For example, with the number 1045, the answer would
	  be 4.</p>

	  <p><b>Algorithm: </b></p>

	  <p>This is one of those problems that is very easy to do by
	  hand: When you have a number, it is given to you as a list
	  of digits, so you just count the digits on the paper--no
	  sweat.  But to a computer, 'look at how many digits are in
	  this number' isn't one of the operations we are allowed to
	  do to numbers.  All we can do is add, subtract, multiply,
	  and divide, and so to solve the problem with a computer, we
	  need to think of how to solve it with only these operations
	  available to us.  </p>

	  <p>So, to get the number of digits in a number
	  mathematically, we can repeatedly divide it by 10 until it
	  gets below 1.  The number of times we have to do this is the
	  number of digits in the number.  For instance, 9 / 10 = 0.9,
	  so we only have to divide once, so the number 9 has one
	  digit.  128 / 10 = 12.8, 12.8 / 10 = 1.28, 1.28 / 10 =
	  0.128.  So it takes three divisions to get to below 1, and
	  indeed, 128 has three digits.</p>

	  <p>To accomplish this programmatically, we will need two
	  variables--one to store the number that we will repeatedly
	  divide--say this is called <pre>n</pre>, and another to
	  store how many times we've divided so far--say this one is
	  called <pre>digit_count</pre>.  Then we can write the
	  algorithm more precisely as: </p>

<code>Step 1: n = 1238129 (or whatever)
Step 2: digit_count = 0
Step 3: Repeat the following as long as n > 1:
	Substep 1: Increment digit_count
	Substep 2: Divide n by 10
Step 4: Print digit_count</code>

<p><b>Program: </b></p>

<python>n = 1238129
digit_count = 0
while(n > 1):
   digit_count = digit_count + 1
   n = n/10
print(digit_count)</python>

<p>You would be right to worry about an off-by-one error--do we start
digit_count at 0 or at 1?  We can tell by single-stepping the program
in a simple case, as we did before, or you can run the program with a
few different inputs as examples.  Convince yourself that we are OK.
</p>

<p>There is also a tricky edge-case that may have slipped your notice,
however: Consider what happens when we start with <pre>n = 1</pre>:
First <pre>digit_count</pre> will be set to 0, and then we'll run the
while loop as long as <pre>n > 1</pre>.  But even at the start, this
test fails, as <pre>n = 1</pre>, so <pre>n</pre> is not greater than
1!  So the stuff inside the while loop gets skipped entirely, and the
value of <pre>digit_count</pre>--namely 0--gets printed.  And this is
definitely the wrong answer--the number '1' has 1 digit!  </p>

<p>In fact, this isn't the only issue--this problem shows up whenever
<pre>n</pre> gets set to 1 during execution, for example if it started
at 1000, we would get the wrong answer of 3.  </p>

<p>To fix this, we simply need to realize that we wrote our algorithm
correctly--we stop if n is below 1--but our program doesn't reflect
this--it stops if n is below 1 <i>or if n is equal to 1</i>.  We can
rectify this by telling it to continue with the while loop even when n
is 1:

<python>n = 1238129
digit_count = 0
while(n >= 1):
   digit_count = digit_count + 1
   n = n/10
print(digit_count)</python>

</p>

<p><b>Debrief: </b></p>

<p>We should note that this program doesn't work for non-integers, nor
for integers below 1.  </p>

<p>If you played around with the factorial program, you probably got
the sense that factorials were pretty huge.  To get an idea of how
huge, we can combine our digit-counting program with our factorial
program to find out how many digits are in 99!: </p>

<python>input = 99
answer = 1
counter = 1
while(counter &lt; input): 
   counter = counter + 1
   answer = answer * counter
n = answer
digit_count = 0
while(n >= 1):
   digit_count = digit_count + 1
   n = n/10
print(digit_count)</python>

	</text>
      </section>
  </section>
  <section>
    <title>Applications</title>
    <text>
      <p> In this section, we'll revisit our three example
      applications of search engine, game console, and cell phone, to
      see how we might start to apply our limited knowledge of Python
      in the direction of creating these systems.  The programs we'll
      write here will only be indicative of the ideas involved, since
      we don't yet know enough of the Python language to provide a
      realistic solution for any of them--for instance, we don't even
      have a way of getting user input without requiring the user to
      edit the program!  But we'll bash on ahead anyway and see what
      we can do:
      </p>
    </text>
    
    <section>
      <title>Search engine</title>
      <text>
	<p>As we discussed in chapter 1, a working search engine solves many different problems--storing lots of files on lots of computers, displaying a search box to millions of people per minute, and more.  Here, we shall suppose we have the files split into words and each word is stored in its own variable, like so:   </p>

<code>file1_name = &quot;Ode on the death of a favorite cat&quot;
file1_word1 = &quot;twas&quot;
file1_word2 = &quot;on&quot;
file1_word3 = &quot;a&quot;
file1_word4 = &quot;lofty&quot;
file1_word5 = &quot;vases&quot;
file1_word6 = &quot;side&quot;
file2_name = &quot;Elegy written in a country churchyard&quot;
file2_word1 = &quot;the&quot;
file2_word2 = &quot;curfew&quot;
file2_word3 = &quot;tolls&quot;
file2_word4 = &quot;the&quot;
file2_word5 = &quot;knell&quot;
file2_word6 = &quot;of&quot;
file2_word7 = &quot;parting&quot;
file2_word8 = &quot;day&quot;</code>

<p>We'll also suppose the word that the user searched for is already stored for us in a variable.  Then the game is just to take each word from each file and compare it to the search word.  </p>

<code>search_word = &quot;the&quot;</code>

<p>Then, to make do the actual searching is just a painful slog of if statements like: </p>

<code>if(search_word == file1_word1): 
   print(file1_name)</code>

<p>So the full program looks like: </p>

<python>search_word = &quot;the&quot;
file1_name = &quot;Ode on the death of a favorite cat&quot;
file1_word1 = &quot;twas&quot;
file1_word2 = &quot;on&quot;
file1_word3 = &quot;a&quot;
file1_word4 = &quot;lofty&quot;
file1_word5 = &quot;vases&quot;
file1_word6 = &quot;side&quot;
file2_name = &quot;Elegy written in a country churchyard&quot;
file2_word1 = &quot;the&quot;
file2_word2 = &quot;curfew&quot;
file2_word3 = &quot;tolls&quot;
file2_word4 = &quot;the&quot;
file2_word5 = &quot;knell&quot;
file2_word6 = &quot;of&quot;
file2_word7 = &quot;parting&quot;
file2_word8 = &quot;day&quot;
if(search_word == file1_word1): 
   print(file1_name)
if(search_word == file1_word2): 
   print(file1_name)
if(search_word == file1_word3): 
   print(file1_name)
if(search_word == file1_word4): 
   print(file1_name)
if(search_word == file1_word5): 
   print(file1_name)
if(search_word == file1_word6): 
   print(file1_name)
if(search_word == file2_word1): 
   print(file2_name)
if(search_word == file2_word2): 
   print(file2_name)
if(search_word == file2_word3): 
   print(file2_name)
if(search_word == file2_word4): 
   print(file2_name)
if(search_word == file2_word5): 
   print(file2_name)
if(search_word == file2_word6): 
   print(file2_name)
if(search_word == file2_word7): 
   print(file2_name)
if(search_word == file2_word8): 
   print(file2_name)</python>
      </text>
    </section>
    <section>
      <title>Game console</title>
      <text>
<p><b>Comparing scores:</b></p>

<p>We started this chapter with an example algorithm for comparing the scores of three players.  We'll now implement this algorithm as a Python program, supposing we have the three scores stored in three variables, say like so: </p>

<code>player1_score = 20
player2_score = 21
player3_score = -1</code>

<p>Recall the algorithm: </p>

<code>If score1 is greater than score2 and score1 is also
greater than score3: Display the text: &quot;PLAYER 1 WINS!&quot;

If not, then if score2 is greater than score1 and score2 is also
greater than score3: Display the text: &quot;PLAYER 2 WINS!&quot;

If not, then if score3 is greater than score1 and score3 is also
greater than score2: Display the text: &quot;PLAYER 3 WINS!&quot;
</code>

<p>So the main difficulty is in performing this combined test, where
we test two things at once.  We can perform one of the tests like:
</p>

<code>if(player1_score > player2_score):
   ...
</code>

<p>But then we need to put the second test of step 1, namely, player1_score > player3_score, somewhere.  The point is that we can break up the algorithm to perform only one test at a time: Instead of

<code>If score1 is greater than score2 and score1 is also
greater than score3: Display the text: &quot;PLAYER 1 WINS!&quot;</code>

We can say

<code>If score1 is greater than score2, then test if score1 is greater
than score3.  If this second test is true, print the text: &quot;PLAYER 1 WINS!&quot;</code>

Thus we get the code:

<code>if(player1_score > player2_score):
   if(player1_score > player3_score):
      print(&quot;PLAYER 1 WINS&quot;)</code>

So for a full version of this program, we get:

<python>player1_score = 20
player2_score = 21
player3_score = -1
if(player1_score > player2_score):
   if(player1_score > player3_score):
      print(&quot;PLAYER 1 WINS&quot;)
if(player2_score > player1_score):
   if(player2_score > player3_score):
      print(&quot;PLAYER 2 WINS&quot;)
if(player3_score > player1_score):
   if(player3_score > player2_score):
      print(&quot;PLAYER 3 WINS&quot;)</python>
</p>

<p><b>Computing distances: </b></p>

<p>As discussed at in chapter 1, one of the things that happens
frequently in a game is that we need to compute distances between
points.  Let us say we are dealing with 2D points, whose coordinates
are stored in variables like:

<code>point1_x = 20
point1_y = 55
point2_x = 10
point2_y = 60</code>

representing point 1 being (20,55) and point2 being (10,60).  </p>

<p>And say we want to see which point is furthest away from the origin--(0,0).  Then the algorithm is straightforward: </p>

<code>Compute the distance of point 1 to the origin and store it in a variable
Compute the distance of point 2 to the origin and store it in another variable
If the first variable is larger than the second, print that point 1 is closer to the origin
If the second variable is larger than the first, print that point 2 is closer to the origin
If the two variables are equal, print that they are the same distance to the origin
</code>

<p>The one problem that presents is that the distance to the origin is given by </p>

<code>√(x1*x1 + y1*y1)</code>

<p>but we don't yet have an operation for square root.  Fortunately,
instead of comparing √(x1*x1 + y1*y1) with √(x2*x2 + y2*y2), we
can just compare, x1*x1 + y1*y1 with x2*x2 + y2*y2, since sqrt is an
increasing function.  So we'll modify our algorithm to not compute the
distances, but rather the square distances, and get the program: </p>

<python>point1_x = 20
point1_y = 55
point2_x = 10
point2_y = 60
square_distance1 = point1_x*point1_x + point1_y*point1_y
square_distance2 = point2_x*point2_x + point2_y*point2_y
if(square_distance1 &lt; square_distance2): 
   print(&quot;Point 1 is closer to origin&quot;)
if(square_distance1 > square_distance2): 
   print(&quot;Point 2 is closer to origin&quot;)
if(square_distance1 == square_distance2): 
   print(&quot;Points are the same distance from the origin&quot;)</python>
      </text>
    </section>
    <section>
      <title>Mobile phone</title>
      <text>
	<p>Recall our earlier discussion of a cell phone with an
	accelerometer--a noisy sensor.  We want to estimate our
	acceleration, but the readings may be affected--sometimes
	rather dramatically, by random noise.  Since the noise is
	equally likely to cause the sensor to overestimate as to
	underestimate, we can take some number of readings from the
	sensor, and instead of taking any individual reading as the
	actual acceleration value, we can take the average of all of
	them.  </p>

	<p>In this example, we suppose we've somehow got 5 readings
	from the sensor stored in some variables for us.  (For the
	moment, we'll just store the values rather than actually read
	them from a sensor, since we're studying how to do the
	averaging, and not yet how to talk to sensors): </p>

<python>
reading_1 = 20
reading_2 = 21
reading_3 = 15
reading_4 = 22
reading_5 = 20
summation = reading_1 + reading_2 + reading_3 + reading_4 + reading_5
average = summation/5
print(&quot;The average is: &quot;)
print(average)
</python>
      </text>
    </section>

    <section>
      <title>Debrief</title>
      <text>
	<p>So after all of that, where are we on our journey?  At this
	point, recall, we were working our way down the tower of
	abstractions.  We're still in the top half of the tower--those
	layers that deal with programming a computer (as opposed to
	building a computer), and in particular we're currently at the
	programming language level, just above the ISA.  That is, we
	are not programming the computer directly, but we are writing
	code that we trust can be turned into ISA code and actually be
	run by a computer.</p>

	<p>This chapter hopefully introduced us to the concepts and
	mindset involved with programming at this level, as well as
	some experience with actual programming.  However, this
	experience may have at times felt somewhat limited or
	unwieldy.  This was indeed the case--we intentionally
	restricted attention to a small subset of the Python language
	focus on the concepts and thought process with the minimal
	useful complexity that we could get away with.  </p>
	
	<p>As a result, none of the preceding "real world" examples
	contains realistic production-quality code.  They do, however,
	contain the nuggets of basic ideas that are used in those
	worlds in a more full, unrestricted programming language
	environment.  In the next chapter, we'll learn some more
	advanced constructs in Python that will allow far less
	cumbersome implementations.</p>

	<p>For example, some unsatisfying features that will be
	rectified in the next chapter include: 
	<ul><li>We didn't allow user input</li>
	<li>Our method of output was only console printing</li>
	<li>The only way of storing a massive collection of values was to use
	a massive number of variables</li>
	</ul>
	Stay tuned!</p>
      </text>
    </section>
  </section>
  
  <section>
    <title>Exercises</title>
    <exercises />
  </section>
</section>
