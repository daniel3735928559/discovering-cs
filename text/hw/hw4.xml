<?xml version="1.0" encoding="UTF-8"?>
<homework>
  <hw>
<q>Convert the following numbers to binary(unsigned) and then hexadecimal:
<ol>
<li>12</li>
<li>35</li>
<li>67</li>
<li>5</li>
<li>129</li>
</ol></q>
<q>Convert the following unsigned binary numbers to decimal:
<ol>
<li>11111</li>
<li>11011</li>
<li>01</li>
<li>1111011111</li>
<li>10101010</li>
<li>001101</li>
</ol></q>
<q>Convert these negative decimal numbers to binary(two’s complement):
<ol>
<li>-21</li>
<li>-12</li>
<li>-1</li>
<li>-9</li>
<li>-45</li>
</ol>
</q>
<q>In this section we performed the operation y = x + 5 using unary representation (BBs). Intuitively, you may have assumed that we could create the “y” container with 5 BBs and then simply dump the contents of the “x” container into it as well. However, instead, we went through all the trouble of weighing out the same number of BBs. Why is all this necessary? What is wrong with dumping x’s contents into y?
</q>
<q> As you have seen in the last few chapters, there are many ways to interpret the same sequence of zeros and ones. For example, the byte 11010111 has different values when represented as unsigned vs. signed. Fill in the representations for this byte 11010111
<ol>
<li>unsigned</li>
<li>signed</li>
<li>sign bit</li>
<li>two's complement</li>
</ol></q>
<q>What is the role of the MSBs in both of the signed representations from this chapter?
</q>
<q>Convert the following hexadecimal number to its floating point value: 7D00 (Note: there is no direct way to do this; you must first translate the hexadecimal number into an intermediate binary number in order to do the floating point conversion.)
</q>
<q>What is the difference between a signed bit representation and a two’s complement representation in binary?
</q>
<q>What are advantages of floating point representation over fixed point representation?
</q>
<q>How are binary numbers translated into hexadecimal numbers?
</q>
<q>What are the hexadecimal numbers and what decimal numbers do they correspond to?
</q>
<q>(4.1.1) Why don’t we use Unary representation for storing information in computers?
</q>
<q>(4.1.1) What would be the Unary representation of the decimal number 7?
</q>
<q>(4.1.2) Define byte, word, and nibble.
</q>
<q>(4.1.2) What is the MSB in the binary number 1010? What’s the LSB?
</q>
<q>(4.1.2) How many non-negative integers can be represented by a nibble? Which is the largest of these integers? 
</q>
<q> (4.1.2) Assuming non-negative integer binary representation, which decimal number does 10010 equal to?
</q>
<q>(4.1.3) Why is two’s complement preferred over sign-magnitude to denote negative integers?
</q>
<q>(4.1.3) What is the smallest (most negative) integer you can represent by a nibble, when using two’s complement representation? What if you use signed-magnitude representation? What about the largest integer in either case? How many integers in total in either case?
</q>
<q>How would you write the following in 2’s complement notation: +39, - 39?
</q>
<q>(4.1.4) How does fixed-point representation of real numbers vary from floating-point representation?
</q>
<q>(4.1.4) What decimal number does 101.101 represent? (Note this is a fixed point representation)
</q>
<q>(4.1.4) Assuming Floating point representation mentioned in the book, what decimal number do the following represent : 1,11000,0010000000   and    1,00110,0110000000    (The commas have been added just to make reading the various components of the representation easier)
</q>
<q>Assuming two’s complement notation, perform the following:
<ol>
<li>01000011 + 00100011</li>
<li>11000011 + 00100011</li>
<li>11000011 + 10100011</li>
<li>01100011 + 01100011</li>
<li>01000011 - 00100011</li>
<li>11000011 - 00100011</li>
<li>11000011 - 10100011</li>
<li>00100011 - 11000011</li>
</ol>
<p>Which of the above would cause an overflow, assuming the memory width is 8 bits.</p>
</q>
<q>Convert the following numbers and perform the functions
<ol>
<li>3 + 4</li>
<li>5 - 4</li>
<li>9 - 2</li>
<li>13 - 5</li>
<li>4 - 14</li>
<li>4 + 9</li>
</ol></q>
<q>The number 183 can be interpreted as a decimal or hexadecimal number, but not binary. Why is this? Convert the decimal number 183 to hexadecimal, and then convert hexadecimal number 183 to decimal.
</q>
<q>What is the sum 11010011 + 01001010 in unsigned binary? In two’s complement binary?
</q>
<q>How are two’s complement numbers negated? Which arithmetic operations are easily allowed with these numbers?
</q>
<q>Construct a truth table for a NAND gate
</q>
<q>Construct a truth table for a NOR gate
</q>
<q>This chapter introduces some ways to utilize the binary operations we learned to optimize code. The first trick is to left shift instead of multiplying by 2. This trick is related to the fact that every digit in the binary number represents a different power of 2, and you could make a similar conclusion about left-shifting decimal numbers. Write the binary and decimal values of each number below to see how binary and decimal are related to this left-shift trick:
<p>00000001</p>
<p>00000010</p>
<p>00000100</p>
<p>00001000</p>
<p>00010000</p>
<p>00100000</p>
<p>01000000</p>
<p>10000000</p>
</q>
<q>Now it should be obvious why/how the left-shift trick works. What effect does left shifting have on decimal numbers? How does this relate to the place values of each representation?
</q>
<q>Another trick from this section is that x^x = 0 always, for any sequence x. Using the XOR truth table from the previous section, perform this trick for the following sequences and explain why this is always true.
<ol>
<li>0</li>
<li>1</li>
<li>0000</li>
<li>1111</li>
<li>01010101</li>
</ol></q>
<q>The last trick from this section is that you can negate an integer called x represented with a sign bit, by changing its value to x ^ 10000000. How does this operation work when x’s sign bit is 0 as opposed to 1? To answer this, compute x ^ 10000000 for the following x values (and convert all signed binary values to decimal when you’re done):
<ol>
<li>x = 10101010</li>
<li>x = 01010101</li>
</ol></q>
<q>What is 11010011 &amp; 01001010, using the boolean operator “and”?</q>
<q>What is 01001101 | 01100101, using the boolean operator “or”?</q>
<q>What is 10100111 ^ 01111001, using the boolean operator “xor”?</q>
<q>What is ~10011110, using the boolean operator “not”? </q>
<q>Write the truth tables for AND, OR, and XOR gates (two inputs), and the NOT gate (1 input).</q>
<q>Which gate gives an output one only when exactly one of the two inputs is 1?</q>
<q>What would the following result in? (When x appears, assume it is an 8-bit binary number)
<ol>
<li>10010001>>2</li>
<li>10010001 | 01011001</li>
<li>10010001 &amp; 01011001</li>
<li>10010001 ^ 01011001</li>
<li>~10010001</li>
<li>x &amp; x</li>
<li>x | x</li>
<li>x &amp; ~x</li>
<li>x | ~x</li>
<li>x ^ x</li>
<li>x ^ ~x</li>
</ol></q>
</hw>
</homework>
