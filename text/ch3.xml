<?xml version="1.0" encoding="ISO-8859-1"?><?xml-stylesheet href="box.xsl" type="text/xsl"?><section number="3">
  <title>Advanced Programming</title>
  <section>
    <title>Practical Programming</title>

    <summary>In the previous chapter, we introduced a simplified
    version of Python in order to communicate the fundamental ideas of
    programming.  In this chapter, we'll explore more features of
    Python that allow us to complete the tasks that we had in chapter
    2 more simply. </summary>
    
    <text>
      <p>In our journey down the tower of abstractions, we are
      currently discussing high-level programming languages, the tools
      with which large-scale systems are built.  The goal of the
      previous chapter was to introduce the basic concepts of
      programming--things like syntax, semantics, the rigidity of a
      programming language, and how to think within a prescribed set
      of rules to accomplish basic tasks.  For this purpose, we
      introduced a basic subset of Python.  </p>
      
      <p>As our goal is to drill down into the lower layers of
      abstraction rather than to give a full introduction to actual
      programming (which is easily an entire book all on its own),
      we'll only spend this brief chapter talking about more advanced
      features of Python, and then just enough to convince ourselves
      that Python can actually solve the real-world probems we posed
      in a sensible way.  For example, think back to the code that
      simulated search-engine behavior, searching a file for a
      user-supplied string: </p>

      <code>search_word = &quot;the&quot;
file1_name = &quot;Ode on the death of a favorite cat&quot;
file1_word1 = &quot;twas&quot;
file1_word2 = &quot;on&quot;
file1_word3 = &quot;a&quot;
file1_word4 = &quot;lofty&quot;
file1_word5 = &quot;vases&quot;
file1_word6 = &quot;side&quot;
file2_name = &quot;Elegy written in a country churchyard&quot;
file2_word1 = &quot;the&quot;
file2_word2 = &quot;curfew&quot;
file2_word3 = &quot;tolls&quot;
file2_word4 = &quot;the&quot;
file2_word5 = &quot;knell&quot;
file2_word6 = &quot;of&quot;
file2_word7 = &quot;parting&quot;
file2_word8 = &quot;day&quot;
if(search_word == file1_word1): 
   print(file1_name)
if(search_word == file1_word2): 
   print(file1_name)
if(search_word == file1_word3): 
   print(file1_name)
if(search_word == file1_word4): 
   print(file1_name)
if(search_word == file1_word5): 
   print(file1_name)
if(search_word == file1_word6): 
   print(file1_name)
if(search_word == file2_word1): 
   print(file2_name)
if(search_word == file2_word2): 
   print(file2_name)
if(search_word == file2_word3): 
   print(file2_name)
if(search_word == file2_word4): 
   print(file2_name)
if(search_word == file2_word5): 
   print(file2_name)
if(search_word == file2_word6): 
   print(file2_name)
if(search_word == file2_word7): 
   print(file2_name)
if(search_word == file2_word8): 
   print(file2_name)</code>

	<p>There are many feature of this that would count as
	less-than-delightful:

	<ul>
	  <li>We aren't actually reading a file.  We're pretending we
	  got the words from a file into separate variables.</li>
	  <li>We aren't actually getting user input from a prompt, but
	  instead require users to change the program when they want
	  to search for a different word.</li>
	  <li>If we want to add another word to the file, we have to
	  add a whole new variable and a whole other if block to test
	  that word.</li>
	  <li>We're repeating a lot of similar code.  So if we
	  decided, say, we wanted to print something else along with
	  the name of the file that contained the query word, we'd
	  have to change every single if-block.  Quite the chore.</li>
	  <li>If we had accidentally typoed one of the variable names,
	  we may skip a word from the file and not realise it.</li>
	</ul>
	
	Several of these issues deal with the unrealistic nature of
	the example, which we'll certainly rectify in this chapter.
	However, some of them get at further concerns beyond realism
	and even beyond those of efficiency and scalability that we
	discussed in the previous chapter.  Two such concerns are
	readability of code, and maintainability of code.  These new
	concerns start to matter more when your code gets very large
	and has many users, but are worth at least thinking about for
	any code you write.
	</p>

	<p><def term="readability"><b>Readability</b> refers to how
	easy it is to look at the code and both understand what it is
	meant to do and verify that it actually does that.
	Readability does not necessarily mean concision.  Doing a
	complex task in one really clever line of code may obscure
	what task that line is actually performing.  Breaking it into
	two or three more perspicuous lines may actually improve
	readability.  </def></p>
	
	<p><def term="maintainability"><b>Maintainability</b> refers to
	how easy it is to maintain the code.  This includes things
	like:

	<ul>
	  <li>Identifying and fixing a bug.</li>
	  <li>Changing the behavior of the code.</li>
	  <li>Adding a new feature.</li>
	</ul>

	Code is said to be maintainable if it is written in such a way
	that makes these three tasks easy.  </def></p>
	
	<p>Our search engine code from the previous chapter fails
	miserably on both of these measures: As far as readability, it
	is relatively easy to figure out what the code means to do,
	but in order to ensure that it actually does what it is
	supposed to without error, we have to (among other things)
	read through every single if block to ensure there are no
	typos in variable names.  Further, as far as maintainability,
	adding another word requires adding three lines of code.
	Adding another file with even just 100 words (the length of a
	short poem) requires 300 new lines to be added!  While we did
	point out that short code is not necessarily more readable,
	code that is performing a relatively simple task shouldn't be
	hundreds of lines.  And thinking about changing the behavior
	of the code, well, imagine changing it to have it print out
	its output in the format:
	
	<code>"Found a result: [filename]"</code>

	The internal groaning you just experienced speaks for
	itself.</p>

	<p>This is not the fault of our methodology, but of our tools:
	Actual Python has more features than we introduced in the
	previous chapter, and can in fact accomplish this same task in
	maybe five lines of code regardless of how many files you want
	to search.  </p>

	<p>Before we embark on this chapter's brief journey into
	real-world programming, we indulge in one further remark on
	the principles of programming.  The four high-level concerns
	that we've discussed (efficiency, scalability, readability,
	and maintainability), are not independent, and they sometimes
	war against each other.  Sometimes the most efficient way to
	accomplish something is a highly obscure and clever algorithm
	that, when realized in code, obfuscates the purpose of that
	code entirely.  It is also very common in large projects for
	reasonable amounts of efficiency to be sacrificed for the sake
	of having code that can easily be understood and modified in
	the future, say when a new programmer is hired and has to be
	introduced to the existing code that the other programmers
	have written.  </p>
	
	<p>Real-world programming almost always involves
	<b>trade-offs</b>, where we trade in, for example, a small
	amount of efficiency to make the code much more
	maintainable.</p>
      </text>
    </section>
    <section>
      <title>Running actual Python code</title>
      <text>
	<p>The same procedure for running code in the previous chapter
	carries over to this one.  </p>
      </text>
    </section>
    <section>
      <title>Arrays</title>
      <summary>Arrays are a way of storing multiple values in a single
      variable.  The individual values stored in an array can be
      accessed by subscript notation.</summary>

      <text>
	<p>Probably the most notionally offensive example from the
	previous chapter was our program for searching through a file.
	We weren't even really searching through entire files, but
	only through the first lines of the files, and that was
	already incredibly cumbersome.  Imagine how massive a proper
	search program would be if it had to be written this way!</p>

	<p>The method we used in that example was to store all the words
	in all the documents each in its own separate variable.  What
	would be nice is to be able to store all the words for a
	single document in a single variable, but then to be able to
	get each word that is stored individually.  There is in fact a
	way of doing this:
	
	<code>file1_words = ["twas","on","a","lofty","vases","side"]</code>

	Such a variable is called an array.  All the variables we met
	in the previous chapter were storing one value under one name,
	so if we wanted to store multiple values, we needed to make
	several different variables, all with different names.  But
	when dealing with a huge amount of data, as we expect to when
	making a search engine, this becomes inconvenient.  So we have
	arrays, which let us store multiple values in one variable.
	The syntax for creating an array is

	<code><i>variable_name</i> = [<i>expression</i>, <i>expression</i>, ...]</code>

	So, for instance, 
	
<python>x = 4
an_array = ["hello", 2, 9*x, x, "goodbye"]</python>

declares an array with values 

<code>"hello"
2
36
4
"goodbye"</code>

<def term="subscript">Once we have this set up, we can access the individual values stored
in the array with the following <b>subscript</b> notation</def>:

<code>an_array[4]</code>

This accesses entry number 4 in the array.  So if we want to print
this entry, we'd do

<python>x = 4
an_array = ["hello", 2, 9*x, x, "goodbye"]
print(an_array[4])</python>

As a result, we see printed: 

<code>goodbye</code>

Great!  Or is it?  If you were paying attention, you'd notive that
"goodbye" is the 5th entry in the array.  What gives?  In Python (as
in most programming languages that have arrays) the number you put in
the subscript is the offset from the first entry of the array.  So

<code>an_array[4]</code>

means "start at the first value in the array and go 4 to the right".
So, if instead you want the first word, you would start at the first
word and go 0 to the right, i.e.:

<code>an_array[0]</code></p>

<p>An array element such as <icode>an_array[0]</icode> is a variable
like any other, so you can use them in expressions or assignments just
like any other variable:

<python>some_nums = [4,6,99,-1]
some_nums[0] = 5
print(some_nums)
print(some_nums[1])
some_nums[2] = some_nums[1] * some_nums[2]
print(some_nums)
if(some_nums[0] % 2 == 0):
   print("some_nums starts with an even number!")
else:
   print("some_nums starts with an odd number!")</python>

So we see that we can access the various values stored in the array
using this subscript notation, and any particular value in an array
can be used in an expression or assignment just like any other
variable.  In particular, we know how to modify existing elements of
an array, but what if we want to add elements to the array?  Python
allows you to concatenate arrays with the + operator:

<code>array1 = [1,2,3]
array2 = [0,-1,-2]
big_array = array1 + array2
print(big_array)</code>

prints 

<code>[1,2,3,0,-1,-2]</code></p>

<p>So what if we just want to put the value 4 on the end of the array?  

<code>array1 = [1,2,3]</code>

We cannot do

<code>array1[3] = 4</code>

since there is no array1[3].  array1 has only three elements, and so
trying to assign to its fourth will give a logic error.  Instead, we
need to assign array1 to be array1 plus a list containing just the
element 4:

<python>array1 = [1,2,3]
array1 = array1 + [4]
print(array1)</python>

prints:

<code>[1,2,3,4]</code></p>
    </text>
    <section>
      <title>Strings as read-only arrays</title>
      <text>
	<p>We've actually seen some examples of arrays already, namely
	strings.  If you think about all the things we just learned
	how to do with arrays--inspect and edit individual elements
	and concatenate arrays--these are operations we would equally
	want to be able to do to strings:

<python>blah = "Hello World!"
print(blah[6])
print(blah[11])</python>

prints 

<code>W
!</code></p>

<p>So, for instance, if the user has inputted 5 words, and we want to
find all those words they've inputted that start with "a", we can now
test this, since we know how to access the individual letters of a
word.  For example:

<code>word = "betrothed"
print(word[0])</code>

prints the first letter, "b".  Now we don't want to print the
letter, but to use it in a test.  Recall that a test is something of
the form

<code><i>expression comparison expression</i></code>

where the comparison we want is clearly == to test if the first letter
of the word is equal to "a".  Recall an expression is either a number,
string, variable, or combination thereof.  Here, we want to use the
first value in the array called word.</p>

<p>Thus our test will be: 

<code>word[0] == "a"</code>

and we get: 

<code>word = "betrothed"
if(word[0] == "a"):
   print(word[0])</code>

which will not print anything, since word[0] is in fact "b".  Now,
putting this together with 5 random words (which will eventually be
replaced with 5 user inputs):

<code>word1 = "blithe"
word2 = "alphabetic"
word3 = "crocodiles"
word4 = "ate"
word5 = "asparagus"
if(word1[0] == "a"):
   print(word1)
if(word2[0] == "a"):
   print(word2)
if(word3[0] == "a"):
   print(word3)
if(word4[0] == "a"):
   print(word4)
if(word5[0] == "a"):
   print(word5)</code>

This is somewhat reminiscent of our stupid search program, and indeed
we make a slight initial improvement by storing all the words in an
array:

<code>words = ["blithe","alphabetic","crocodiles","ate","asparagus"]</code></p>

<p>But now careful--how do we get, say, the third word in this array?
It is the first value in the words array, so it can be accessed like

<code>words[2]</code>

Indeed: 

<code>words = ["blithe","alphabetic","crocodiles","ate","asparagus"]
print(words[2])</code>

prints 

<code>crocodiles</code></p>

<p>But now how do we get the first letter of the third word?  The
third word is words[2], and this is a string.  How do we get the first
letter of a string?  By appending [0] to the name of the string.  This
string is called words[2], so indeed we can do:

<code>words = ["blithe","alphabetic","crocodiles","ate","asparagus"]
print(words[2][0])</code>

which will print the letter c.  Thus we can modify our code: 

<python>words = ["blithe","alphabetic","crocodiles","ate","asparagus"]
w = words[0]
if(w[0] == "a"):
   print(w)
w = words[1]
if(w[0] == "a"):
   print(w)
w = words[2]
if(w[0] == "a"):
   print(w)
w = words[3]
if(w[0] == "a"):
   print(w)
w = words[4]
if(w[0] == "a"):
   print(w)</python>

As with the search program, we'll learn how to improve this later.  </p>

<aside><p>As a remark, we said that arrays can store any list of values, and that those values can be anything that is allowed in a variable.  But an array is allowed in a variable!  So can we store an array with arrays as its values?  The answer is "yes", and this is in fact what we just did above.  But we can be more direct about it: 

<code>a_big_array = [[1,2,3],[99,-5],[1,2,-1,0,0]]</code>

Then to access the first value of the second array, we can do: a_big_array[1][0].  Recall that a_big_array[1] is the second value in a_big_array, which in this case is [99,-5].  So a_big_array[1] is itself an array, and to get its first value, we append [0].  </p>

<p>This is called a 2-dimensional array.  So, for example, if you wanted to store the state of a tic-tac-toe game, you could store: 

<code>board = [["X","O","_"],["_","X","O"],["_","_","_"]]</code>

and you could print the board with: 

<code>print(board[0][0] + board[0][1] + board[0][2])
print(board[1][0] + board[1][1] + board[1][2])
print(board[2][0] + board[2][1] + board[2][2])</code>

which prints

<code>XO_
_XO
___</code>
</p>

</aside>

      </text>
    </section>
    <section>
      <title>Search engine, revisited</title>
      <text>
	<p>Now that we have a basic mechanism for storing the words in
	our files in the search engine example, let us go through an
	example of searching one of them.  </p>

	<p>Recall we could store the words in an array like: 
	
	  <code>file1_words = ["twas","on","a","lofty","vases","side"]</code>

	  Now we have an input word like

	  <code>search_word = "the"</code>

	  and we want to compare it to each word in the array.  Of
	  course, as before, we can do this separately like:

	  <code>if(file1_words[0] == search_word):
   ...
if(file1_words[1] == search_word):
   ...</code>

          But that would be only marginally better than what we did
	  before.  But observe: All that changes between the various
	  if lines is a number.  So this is basically begging for a
	  while loop with a counter, as we deployed in the previous
	  chapter:

	  <python>file1_name = "Ode on the death of a favorite cat"
file1_number_of_words = 6
file1_words = ["twas","on","a","lofty","vases","side"]
search_word = "the"
counter = 0
while(counter &lt; file1_number_of_words):
   if(file1_words[counter] == search_word):
      print(file1_name)
   counter = counter + 1</python>

	In fact, we can use the "arrays of arrays" trick to search
	multiple arrays:

	<python>number_of_files = 2
file_names = ["Ode on the death of a favorite cat", "Elegy in a county churchyard"]
file_word_counts = [6,8]
files = [["twas","on","a","lofty","vases","side"], ["the","curfew","tolls","the","knell","of","parting","day"]]
search_word = "the"
file_counter = 0
while(file_counter &lt; number_of_files):
   word_counter = 0
   while(word_counter &lt; file_word_counts[file_counter]):
      file = files[file_counter]
      if(file[word_counter] == search_word):
         print(file_names[file_counter])
      word_counter = word_counter + 1
   file_counter = file_counter + 1
	</python>
	</p>
      </text>
    </section>
  </section>
  
  <section>
    <title>Logical operators</title>
    <summary>Before, an if or while statement could only include one
    test at a time.  In fact, there is a way to combine multiple tests
    using logical operators, specifying either that we want all of the
    tests to pass, or that we want any of the tests to pass.</summary>
    
    <text>
<p>Another feature of the previous chapter's examples that might have
felt somewhat notionally offensive was the following: In order to
check if player 1 won, we had to check if his score was bigger than
player 2's.  And then, in the event that it was, we then had to have
an inside if block to check whether player 1's score was also higher
than player 3's.  And if that held true as well, then we could finally
declare player 1 the winner:

<code>if(player1_score > player2_score):
   if(player1_score > player3_score):
      print("PLAYER 1 WINS")
</code>

One might hope that instead, we can just test two things at once using
something like:

<python>if(player1_score > player2_score and player1_score > player3_score):
   print("PLAYER 1 WINS")</python>

In fact, Python is pleasant enough that literally this actually
works.  More generally, we are allowed to combine the simple tests of
chapter 2 using the logical operators and and or.  So, for instance:

<python>print("Give me a number 0-10, but no 8s--they taste weird")
x = 4
if(x > 0 and x &lt; 10 and x != 8):
   print("good job!")
else:
   if(x == 8):
      print("Yuck!")
else:
   print("BETWEEN 0 AND 10!")
</python>

Or:

<python>print("Give me a number, 0 or 1--your choice")
x = 4
if(x == 0 or x == 1):
   print("Thank you, kind human.")
else:
   print("CAN YOU REALLY NOT FOLLOW SIMPLE DIRECTIONS?")</python></p>

<p>Any combination of multiple tests with your choice of and and or is
valid, but there are some pitfalls:

<python>print("Give me a positive number, either odd or above 10: ")
x = 4
if(x > 0 and x > 10 or x%2 == 1):
   print("Thank you, kind human.")
else:
   print("CAN YOU REALLY NOT FOLLOW SIMPLE DIRECTIONS?")</python>

This program is meant to accept any integer above 10, but also any odd
number 1-9 as well.  However, this program will actually even accept
-1 as a valid input.  The reason is that ands are grouped together
before <icode>or</icode>s.  Put another way, the test could
equivalently have been written:

<code>(x > 0 and x > 10) or x%2 == 1</code>

So when confronted with x = -1, it goes:

<code>
(-1 > 0 and -1 > 10) or -1 % 2 == 1
   THIS IS FALSE        THIS IS TRUE
</code>
And so since one of the tests is true, the combined test has a value
of true.</p>

<p>To fix it, we can clarify our meaning by using parentheses:

<python>print("Give me a positive number, either odd or above 10: ")
x = 4
if(x > 0 and (x > 10 or x%2 == 1)):
   print("Thank you, kind human.")
else:
   print("CAN YOU REALLY NOT FOLLOW SIMPLE DIRECTIONS?")</python>
</p>

    </text>
  </section>
  <section>
    <title>Functions</title>
      <summary>Functions are a way of storing actual code so that it
      can be easily re-used in multiple places in a program.</summary>
      
      <text>	
<p>In the previous chapter, we often set up our code to have certain
variables acting as the inputs to that code.  For instance, recall our
factorial code:

<python>input = 12
answer = 1
counter = 2
while(counter &lt;= input):
   answer = answer * counter
   counter = counter + 1
print(answer)</python>

The advantage of this was that if we wanted to compute instead 60!, we
could just change the first line to

<code>input = 60</code>

and it would happen.  But if in our code we want to compute first the
factorial of 50 and then later that of 90, say, we'll have to have
this same code appearing twice, like:

<code>input = 50
answer = 1
counter = 2
while(counter &lt;= input):
   answer = answer * counter
   counter = counter + 1
print(answer)
...
input = 90
answer = 1
counter = 2
while(counter &lt;= input):
   answer = answer * counter
   counter = counter + 1
print(answer)</code>

This is unpleasant for a lot of reasons.  If in the future we discover
a subtle bug in our factorial code, or even just a faster way to
compute factorials, then we'll have to change our code in two places
rather than one, and will have to be careful to make the same changes
to both bits of code.</p>

<p>This is redolent of the situation we had with variables--if we have
some value, we don't want to recompute it anew each time we want to
use it.  Instead, we compute it once, give it a name, and then can
access it at any time in the future just by using that name.</p>

<p>The idea of a function is to do the same thing again, except for
code.  That is, we can give a bunch of code a name, and then whenever
we want to use it, we can just run it by using its name.</p>

<p>The actual syntax for doing this is a little more complicated
than for variables, however.  For one thing, blocks of code like the
above have certain variables that are acting as inputs, and others
that are acting as outputs.  And when we use the code's name to run
it, we want to be able to tell it what values to use for inputs, and
where to store the outputs.</p>

<p>If we've managed to name the above code factorial, then to compute 50!, we should be able to say

<code>factorial(12)</code>

if we want to store this in some variable called x, then we can do

<code>x = factorial(12)</code></p>

<p>In order to do this, we set up the above code in the following way: 

<code>def <i>function_name</i>(<i>variable_name</i>):
   <i>[lines of code that comprise the function]</i>
   return <i>expression</i></code>
 
<def term="input (function)">The variable named in the parentheses
after the function name is called the <b>input</b> to the
function</def>.  Whenever the function is run, this variable can be
given a new value, which can be used inside the function.  <def
term="body (function)">The indented lines after the function
definition are called the function's <b>body</b></def>.  <def
term="return value (function)">The expression in the final line will
be the output of this function--called its <b>return value</b></def>.
</p>

<p>A function name may be anything that a variable name could be.  </p>

<p>To cause the functionto run, then, we simply use the function's
name like:

<code>function_name(<i>expression</i>)</code></p>

<p>The function's input variable will be set to the value of the
expression, and then the code in the function will be run.  When it
reaches the a return line, the return value will be used as the value
of this function call.  That is, this function call is actually a new
kind of expression, whose value is the return value of the function.
</p>

<p>That was rather a mouthful, so let's go through it slowly with an example: 

<python>def mogrify(x):
   y = x+1
   return 5*y+9*x*x
z = mogrify(2)
print(z)</python>

So the function is named mogrify, and its input is named x.  Then when we run the line 

<code>z = mogrify(2)</code>

which does as described above:

<ol><li>It sets the input variable to the expression specified (in
this case, 2).  So since the input variable was called
<icode>x</icode>, it sets x to be 2.  </li>

<li>Then it runs the code in the function body.  In this case, it runs
the line <icode>y = x + 1</icode>.  Since x was 2, this sets y to be
3.</li>

<li> Finally, when it reaches the a return line, the return value will
be used as the value of this function call.  The line z = mogrify(2)
is an assignment.  So the return value of mogrify(2) is getting
assigned to the variable z.  Which value is it?  According to step 2,
it is the return value of the function call--in this case,
<icode>5*y+9*x*x</icode>, or just 51.
</li></ol>

So the program above will print 51.  </p>

<p>Some bits of code require more than one value as input.  To turn
these into functions, we simply specify more input variables,
separated by commas.  For instance, if we want to specify two points
on a line and want to compute the distance between them, we can have
easily just subtract them.  However, we have to be careful about what
order we do this in.  For instance, if the first point is 3 and the
second is 5, then the distance is 2, which is the second point minus
the first.  But if the second were instead 2, we would have to
subtract in the other order to get the correct answer of 1.  So we use
an if statement as follows (in this example, say the points are -1 and
6):

<python>point1 = -1
point2 = 6
if(point1 &lt; point2): 
   answer = point2-point1
else:
   answer = point1-point2
print(answer)</python></p>

<p>But if we're going to be doing this often, maybe we want it in a function.  Once again, the inputs are relatively clear--point1 and point2--and the output is once again perspicuously called <icode>answer</icode>.  

<python>def line_distance(point1,point2):
   if(point1 &lt; point2): 
      answer = point2-point1
   else:
      answer = point1-point2
   return answer
d = line_distance(3,5)</python>

So when we call 

<code>d = line_distance(3,5)</code>

we will start executing the first line of the function with point1 set
to 3 and point2 set to 5.  Then, because point1 is less than point2,
the if block will be executed, setting answer to point2-point1,
i.e., 2, and the else block will be ignored.  Finally the return value
of the function will be set to answer, i.e., to 2.  And so when we say
<icode>d = line_distance(3,5)</icode>, as we stated earlier, the function call
itself--i.e., the line_distance(3,5) bit--is equal to the return value.
Thus d is assigned the value 2.</p>

      </text>
      <section>
	<title>Composition</title>
	<summary>Since a function call is an expression, and the input
	to a function call must be an expression, we can use a
	function call as an input to another function call.  This is
	technically nothing new, but it is one of the confusing points
	of functions and so bears some discussion all on its
	own.</summary>
	
	<text>
	  <p>As we've described above, when a function appears in an
	  expression, it is treated as being whatever value the
	  function returns.  So, for instance,

	  <python>def f(x):
   y = x*x
   return x + y*y
print("I'm going to compute something!")
print(2*f(3))</python>

	  Let us consider that last line and how it makes sense: it is
	  a print line.  If we look at our chart, we see that inside a
	  print() is allowed only an expression.  So the question then
	  is: is 2*f(3) a valid expression and, if so, what is its
	  value?</p>

	  <p>Well, an expression is supposed to be a number, string,
	  variable, function call (our new addition to the expression
	  family), or combination thereof using operators +, *, -, /,
	  %.  This indeed is a combination of a number and a function
	  call using the operator *, so it is a valid expression.</p>

	  <p>Now what is this expression's value?  As we've seen in the
	  previous section, the way to determine this is to break off
	  from the flow of the program into a sort of sub-flow, where
	  we only consider the function call and step through the
	  function with its own private variables:</p>


	  <table>
	    <tr><td>Current line</td><td>Why we went to this line</td><td>Variables after current line runs</td><td>Output so far</td></tr>

	    <tr>
	      <td><icode>def f(x):</icode></td>
	      <td>
		It was the first line of the program
	      </td>
	      <td>
		(none)
	      </td>
	      <td>
		(none)
	      </td>
	    </tr>

	    <tr>
	      <td><icode>print("I'm going to compute something!")</icode></td>
	      <td>
		The previous lines just defined the function.  Now
		that the function has been defined, we advance to the
		first line after this.
	      </td>
	      <td>(none)
	      </td>
	      <td>
		<icode>"I'm going to compute something!"</icode>
	      </td>
	    </tr>
	    <tr>
	      <td>
		<icode>print(2*f(3))</icode>
	      </td>
	      <td>
		It was the next line
	      </td>
	      <td>
		<icode>x = 3</icode>
	      </td>
	      <td>
		  <icode>"I'm going to compute something!"</icode>
	      </td>
	    </tr>
	    <tr>
	    <td><icode>   y = x*x</icode></td>
	    <td>
	      We just called the function f, so we go to its first line
	    </td>
	    <td>
	      <icode>x = 3, y = 9</icode>
	    </td>
	    <td>
	      <icode>"I'm going to compute something!"</icode>
	    </td>
	  </tr>
	  <tr>
	    <td>
	      <icode>return x + y*y</icode>
	    </td>
	    <td>
	      It was the next line
	    </td>
	    <td>
	      <icode>x = 3, y = 9</icode>
	    </td>
	    <td>
	      
	      <icode>"I'm going to compute something!"</icode>
	    </td>
	  </tr>
	  <tr>
	    <td>
	      <icode>print(2*f(3))</icode>
	    </td>
	    <td>
	      Now that we know the value of <icode>f(3)</icode>, we
	      return to the line that called it, fresh with the
	      knowledge that (in this case), <icode>f(3) = 84</icode>
	    </td>
	    <td>
	      (none)
	    </td>
	    <td>
	      <icode>"I'm going to compute something!"<br />84</icode>
	    </td>
	  </tr>
	  </table>

	  <p>In this example the single-stepping was especially simple,
	  and perhaps we could have understood by eye what would
	  happen, but this mechanical breakdown of how function calls
	  work becomes especially important when we have multiple
	  functions being called on the same line, sometimes inside
	  each other.</p>

	  <p>For instance, it would not be unheard of in a mathematics
	  course (in particular, the following is not Python code) to
	  see functions like:

	  <code>f(x) = x^2+1
g(x) = x/13-1
h(x) = 77+x</code>

	  and then to have to compute

	  <code>f(2*g(h(0)+1))</code>

	  You may already know how to do this intuitively (or possibly
	  not--this is one of the things that trips some people up),
	  but if we're going to do similar things with a computer,
	  we're going to have to understand somewhat mechanically how
	  these things can be done.  So let's take this example.</p>

	  <p>It is clearly f of something, but before we can start
	  plugging anything into f, we have to figure out: it is f of
	  what?  Well, we're plugging in 2*g(h(0)+1).  But to compute
	  this, we need to know g(h(0)+1).</p>

	  <p>OK, what is g(h(0)+1)?  It's g of something, but before we
	  can plug into g, we have to compute what we're plugging
	  in--in this case, h(0)+1.  And to compute that, we need to
	  know h(0).</p>

	  <p>So what is h(0)?  It is 77+0 = 77.  Good.</p>

	  <p>So now we can start to go backward:</p>

	  <p>We needed previously to know g(h(0)+1).  And now that we
	  know h(0), we know this is g(77+1) = g(78).  And g(78) we
	  can compute by plugging in and we get 78/13-1 = 6 - 1 = 5.</p>

	  <p>Before that, we needed to know f(2*g(h(0)+1)).  Now that
	  we know g(h(0)+1) is just 5, we know that this is f(2*5) =
	  f(10), which we can again compute by plugging in: f(10) =
	  10^2+1 = 101.  So the answer is 101.</p>

	  <p>This example was, as problems from math class tend to be,
	  contrived.  But the principle we saw when solving it is one
	  that we'll need now, namely that the first actual function
	  we evaluated was the one that was furthest inside--h(0).
	  Then, once we had that, we could compute what we were
	  plugging into g, and so we computed g(78).  Then, once we
	  had that, we finally knew what we were plugging into f, and
	  so we computed f(10).</p>

	  <p>This composition of functions happens all the time in
	  programming and allows you to express certain things very
	  concisely, provided you can keep your head on straight well
	  enough to do it correctly.</p>

	  <p>You can watch the above steps happen in Python:</p>
	  
<python>def f(x):
   return x*x+1
def g(x):
   return x/13-1
def h(x):
   return 77+x
print(f(2*g(h(0)+1)))</python>
	  
	</text>
      </section>
      <section>
	<title>Scope</title>
	<summary>Variables defined in a function are destroyed (or
	revert to their previous values) once the function
	returns.</summary>
	
	<text>
	  <p>There is some slight danger here regarding variables that
	  were created inside functions:

	  <python>def f(x):
   y = 1
   return x + y
print(f(2))
print(y)</python>

	  We might expect that when we call f(2) on line 4, we then go
	  into the function which, among other things, creates the
	  variable y with value 1.  Then, when we go to print y on
	  line 5, we should merrily see the value 1 as we expect.
	  Instead, what we see is a logic error that the variable
	  <icode>y</icode> was not defined.  The issue, most
	  basically, is that variables that were created inside
	  functions don't continue to exist once the function
	  finishes.</p>

	  <p>So our expectation was:</p>

	  <table><tr><td>Current line</td><td>
	  Why we went to this line</td><td>
	  Variables after current line runs</td><td>
	  Output so far</td></tr><tr>
	  <td><icode>print(f(2))</icode></td>
	  <td>It was the first line (after the definition of the function)</td>
	  <td><icode>x = 2</icode> (x is the input variable of the function f, and so
	  when we call f(2), this sets the input variable to 2)</td>
	  <td>
	  </td>
	</tr><tr><td>  
	  <icode>y = 1</icode></td><td>
	  We just called the function f, so we go to its first line</td><td>
	  <icode>x = 2<br />y = 1</icode></td><td></td></tr><tr>


	  <td><icode>return x + y</icode></td>
	  <td>
	  It was the next line
	  </td>
	  <td>
	  
	  <icode>x = 2<br />y = 1</icode>
	  </td><td></td></tr><tr>

	  <td><icode>print(f(2))</icode></td>
	  <td>
	  We've finished running f, so now we come back here
	  </td>
	  <td>
	  
	  <icode>x = 2<br />y = 1</icode>
	  </td>
	  <td>
	  
	  <icode>3</icode>
	  </td></tr><tr><td>
	  <icode>print(y)</icode></td><td>
	  It was the next line</td><td>
	  <icode>x = 2<br />
	  y = 1</icode></td><td>
	  <icode>3<br />1</icode></td></tr></table>
	
	  <p>Whereas what actually happens is:</p>

	  <table><tr><td>Current line</td><td>
	  Why we went to this line</td><td>
	  Variables after current line runs</td><td>
	  Output so far</td></tr><tr>
	  <td><icode>print(f(2))</icode></td>
	  <td>It was the first line (after the definition of the function)</td>
	  <td><icode>x = 2</icode> (x is the input variable of the function f, and so
	  when we call f(2), this sets the input variable to 2)</td>
	  <td>
	  </td>
	</tr><tr><td>  
	  <icode>y = 1</icode></td><td>
	  We just called the function f, so we go to its first line</td><td>
	  <icode>x = 2<br />y = 1</icode></td><td></td></tr><tr>


	  <td><icode>return x + y</icode></td>
	  <td>
	  It was the next line
	  </td>
	  <td>
	  
	  (Variables from inside the function body no longer exist)
	  </td><td></td></tr><tr>

	  <td><icode>print(f(2))</icode></td>
	  <td>
	  We've finished running f, so now we come back here
	  </td>
	  <td>(none)
	  </td>
	  <td>
	  
	  <icode>3</icode>
	  </td></tr><tr><td>
	  <icode>print(y)</icode></td><td>
	  It was the next line</td><td>
	  (none)</td><td>
	  <icode>3<br />[error message]</icode></td></tr></table>
	
	  <p>But what if the variable existed before the function was
	  called?</p>

<python>def f(x):
   y = 1
   return x + y
y = 2
print(f(3))
print(y)</python>

	  <p>It turns out that this prints</p>

	  <code>4
2</code>
	  
	  <p>But surely what should have happened is that y got created
	  on line 4.  Then we called the function, which, among other
	  things, modifies y to have value 1.  Then later when we
	  print y, it should have value 1, yes?</p>

	  <p>So now we get to what is actually happening with variables
	  in functions, which is that every time a function is called,
	  it gets its own environment, or set of variables that is
	  independent from and doesn't affect the variables either
	  outside the function or in future calls to the function.  So
	  we can in fact more accurately picture what's happening
	  thus:</p>

	  

	  <table><tr><td>Current line</td><td>
	  Why we went to this line</td><td>
	  Variables after current line runs</td><td>
	  Output so far</td></tr><tr>
	  <td>y = 2</td>
	  <td>It was the first line (after the definition of the function)</td>
	  <td>y = 2</td>
	  <td>
	  </td>
	</tr><tr>
	  <td><icode>print(f(3))</icode></td>
	  <td>
	  It was the next line
	  </td>
	  <td>
	  
	  x = 3
	  y = 2
	  </td>
	  <td>
	    </td></tr><tr><td colspan="4">Call to the function f with
	    argument value 3</td></tr><tr>
	  <td><icode>y = 1</icode></td><td>
	  We just called the function f, so we go to its first line</td><td>
	  x = 3
	  y = 1</td><td></td></tr>
	<tr>
	  <td><icode>return x + y</icode></td><td>
	  It was the next line</td><td>
	  x = 3
	  y = 1</td><td></td></tr>
	  <tr><td colspan="4">f ends now with a return value of
	  4</td></tr>
	  
	<tr>
	  <td><icode>print(f(3))</icode></td><td>
	  We now return to the line that called the function with the
	  return value of the function</td><td>
	  y = 2 (The function is over, so any changes it made to any
	  variables are discarded and any variables that existed
	  before the function call retain their previous values</td><td><icode>4</icode></td>
	</tr>
	<tr>
	  <td><icode>print(y)</icode></td><td>
	  It was the next line</td><td>
	  y = 2</td><td><icode>4
2</icode></td>
	</tr>

	  </table>

	  <p>This behaviour also stacks when we call functions from
	  within other functions.  Consider, for example:

<python>def f(x):
   y = 1
   return x - y
def g(x):
   y = x*x
   z = f(x+y)
   print(y)
   return z
y = 2
print(g(3))
print(y)</python>

          Here, <icode>y</icode> is initially set to 2.  Then we call
          the function <icode>g</icode>, which sets <icode>y</icode>
          (in this case to 9) and in turn calls <icode>f</icode>,
          which sets <icode>y</icode> yet again, this time to 1.  But
          when <icode>f</icode> returns and we go back to
          <icode>g</icode>, then the value of <icode>y</icode> that
          <icode>g</icode> set is restored.  And finally, when
          <icode>g</icode> returns, the value of <icode>y</icode> that
          was set before the call to <icode>g</icode> is again
          restored.</p>
	</text>
      </section>
    </section>
    
    <section>
      <title>Library functions</title>
      <summary>Now that we know about functions, we can use some
      functions that come pre-packaged with Python (or otherwise).
      These are called library functions. </summary>
      <text>
	<p>Functions are useful to us when writing our programs
	because they help us organise our code more nicely.  But one
	of the great advantages of Python is that it comes with many,
	many functions already written that perform various difficult
	tasks.  From displaying graphics to a screen, to playing
	sounds, to getting mouse click information, there is a
	pre-written function for almost everything.  <def
	term="library function">These pre-written functions are called
	<b>library functions</b></def>.  </p>

	<p>As a note, one of the things we have conspicuously omitted
	from our explanation of Python to date was input.  This is
	because input is performed mainly using library functions.  So
	we are now ready to introduce various kinds of input
	functions.  </p>

	<p><def term="module">In Python, library functions are
	contained in <b>modules</b>--separate pieces of code that can
	be loaded into our programs and that contain functions that
	can be used from those programs.</def> In Python, the way to
	load a module is with an <icode>import</icode> line:

	<code>import <i>module_name</i></code>

	This will make it possible to then call functions from that
	module, which will be named like this:

	<code><i>module_name</i>.<i>function_name</i></code>

	For example, the module that deals with input is called
	<icode>input</icode>.  So if we import it, get notice that
	this adds two new functions:
	<icode>input.get_num(prompt)</icode> and
	<icode>input.get_string(prompt)</icode>.  These functions will
	display a window asking the user to input a number or a string
	(respectively) and prompting them with whatever string was
	supplied in the argument.  They return the value that was
	inputted.  For example:

<python>import input

name = input.get_string("Enter your name")
age = input.get_num("Enter your age")
print("Hello "+name + "!")
if(age % 2 == 0):
   print("Your age is even!")
else:
   print("Your age is odd!")
</python>
	</p>

	We can summarise the contents of the <icode>input</icode>
	module with a table:

	<table>
	  <tr><td>Function</td><td>Arguments</td><td>Return
	  value</td></tr>
	  
	  <tr><td><icode>input.get_num(prompt)</icode></td><td><icode>prompt</icode>
	  is a string that will be displayed in the prompt where the
	  user may enter a number</td><td>The number that the user
	  entered will be returned by the function</td></tr>
	  
	  <tr><td><icode>input.get_string(prompt)</icode></td><td><icode>prompt</icode>
	  is a string that will be displayed in the prompt where the
	  user may enter a string</td><td>The string that the user
	  entered will be returned by the function</td></tr>
	</table>

	<p>Part of the power of Python is that it has many modules
	with functions that perform many complex tasks, meaning
	programmers can rely on modules written by others for common
	functionality, and can therefore concentrate on designing the
	code specific to their application.</p>
	
	<p>This is the greatest power of a high-level programming
	language like Python, and the feature that enables it to be
	most effectively used for practical tasks like programming
	search engines and video games and so on.  </p>

	<p>As another example of a Python module that performs a very
	complicated task, we introduce the <icode>googlemaps</icode>
	module, which provides a function that gives directions from a
	starting address to a destination address.</p>

	<table>
	  <tr><td>Function</td><td>Arguments</td><td>Return
	  value</td></tr>
	  
	  <tr><td><icode>googlemaps.init()</icode></td><td>No
	  arguments</td><td>This function does the work needed to set
	  up communication with the Google Maps server.  It must be
	  called only once in the program, and must be before any
	  other googlemaps functions are called.</td></tr>
	  
	  <tr><td><icode>googlemaps.directions(start,
	  end)</icode></td><td><icode>start</icode> is a string with
	  the address from which navigation should start, and
	  <icode>end</icode> is a string with the destination
	  address</td><td>The function returns an array whose entries
	  are the steps in navigating from the starting address to the
	  ending address.</td></tr>
	</table>	

	<p>
	For example:
	
	  <python>import googlemaps
googlemaps.init()
dirs = googlemaps.directions("North/Clyburn, Chicago, IL","Centrailia, PA")
i = 0
while(i &lt; len(dirs)):
   print(dirs[i])
   i = i+1</python>

        If you run this program, it should output the directions from
        The North and Clyburn Red Line station in Chicago to
        Centrailia, Pennsylvania.  You can even combine the two
	libraries we've learned so far to let the user provide the
	start and end addresses:

	
	<python>import googlemaps
import input
googlemaps.init()
start = input.get_string("Enter the starting address")
end = input.get_string("Enter the ending address")
dirs = googlemaps.directions(start, end)
i = 0
while(i &lt; len(dirs)):
   print(dirs[i])
   i = i+1</python>

   We'll learn more library functions as we go through some examples.
	</p>
      </text>
    </section>
    <section>
      <title>More simple examples</title>
      <text></text>
      <section>
	<title>Square Roots</title>
	<text>
	  <p>One of the early examples of an algorithm in this text
	  was one for computing the square root of a number.  Since
	  this is a common operation that comes up in distance
	  calculations (among other things), we want a function that
	  will do this for us.  Something like:

	  <code>def square_root(x):
   # ... something</code>


          Now we just have to fill in the something.</p>
	  
	  <p>Let us recap our algorithm for computing the square root
	  of x:

	  <ol>
	    <li>Start by changing s to be s = x/2.  </li>
	    <li>Take whatever s is currently and add the number x/s to it,
	    making that sum the new value of s.</li>
	    <li>Divide s by 2, making the result the new value of s.</li>
	    <li>If s*s is not yet as close as we want it to be to x,
	    return to step 2 and continue from there.</li>
	  </ol>

	  We can phrase this now in terms of variables to start
	  getting it to look a little more like a Python program:


	  <ol>
	    <li><icode>s = x/2</icode></li>
	    <li><icode>s = s + x/s</icode></li>
	    <li><icode>s = s/2</icode></li>
	    <li>If s*s is not yet as close as we want it to be to x,
	    return to step 2 and continue from there.</li>
	  </ol>

	  So most of that translates literally into Python, but the
	  last step is indicating some kind of a loop that contains
	  inside it steps 2 and 3.  So maybe it should be
	  (approximately):

	  <code>def square_root(x):
   s = x/s
   while(<i>s*s is not yet close to x</i>):
      s = s + x/s
      s = s/2
   return s</code>

	  Great!  So how do we tell if s*s is close to x?  First, we
	  have to specify how close we want them to be.  Let's say we
	  want the first 5 digits after the decimal to be correct.
	  This means that we need s*s and x to be within 0.000001 of
	  each other.  </p>
	  
	  <p>But how, in turn, do we test this?  A good first guess
	  would be <icode>s*s-x &lt; 0.000001</icode>.  The problem is
	  that if somehow s*s is 4 and x is 8, then
	  
	  <icode>s*s - x</icode> will be -4, which is definitely less
	  than 0.000001.  Of course, what we want is not just for
	  <icode>s*s-x</icode> to be small (negative numbers count as
	  very small indeed), but for the <i>absolute value</i> of
	  this quantity to be small.  </p>

	  <p>But we cannot simply write <icode>|s*s-x|</icode> to get
	  the absolute value in a Python program, as this is not valid
	  syntax (check the syntax tree and behold the absence of any
	  "|" operator).  </p>

	  <p>However, if we had a function, say <icode>abs_val(x)</icode>,
	  that computed the absolute value, then we could instead
	  write <icode>abs_val(s*s-x)</icode> for this absolute value, and
	  then our function would become:
	  <code>def square_root(x):
   s = x/s
   while(abs_val(s*s-x) &lt; 0.000001):
      s = s + x/s
      s = s/2
   return s</code>

          Of course, we don't have any <icode>abs_val</icode> function,
	  but that's OK--now that we've solved the problem at hand
	  supposing we had one, now we can go ahead and try to write
	  that as a sub-problem.  </p>

	  <p><b>The <icode>abs_val(x)</icode> function: </b> The absolute
	  value function should receive an argument x and return just
	  x unchanged if x is positive.  But if x is negative, we want
	  to return "x, but made positive".  And how do we make a
	  negative number positive?  Negate it!  So it should return
	  <icode>x</icode> if <icode>x</icode> is positive, and
	  <icode>-x</icode> if <icode>x</icode> is negative.  To wit:

	  <python>def abs_val(x):
   if(x &lt; 0):
      return -x
   return x</python>

          There is kind of a corner-case to think about here: Not all
          numbers are positive or negative.  Specifically, 0 is
          neither, so we should make sure our function behaves
          properly when the argument is 0.  But in fact it does return
	  0 in this case, so all is well.
	  </p>

	  <p>Now that we have our <icode>abs_val</icode> function and our
	  <icode>square_root</icode> function, we can put them all
	  together into a square root calculating program: 
	  
<python>import input
def abs_val(x):
   if(x &lt; 0):
      return -x
   return x

def square_root(x):
   s = x/2
   while(abs_val(s*s-x) > 0.000001):
      s = s+x/s
      s = s/2
   return s

x = input.get_num("Enter x")
print(square_root(x))</python>

	  </p>

	  <p><b>Debrief: </b>Take note of the strategy we used here:
	  We wrote down the algorithm as usual, turned as much into
	  code as we could, and then had a look at each of the pieces
	  that we couldn't as easily turn into code.  </p>

	  <p>Once we zeroed in on the problem of "How do we check if
	  s*s is close to x?", we were able to write a description of
	  what we wanted: "Absolute value of s*s-x needs to be less
	  than 0.000001".  At this point, we didn't know how to
	  compute absolute values in Python, but we realised we could
	  pretend we had a function that would do it for us, and could
	  therefore defer the problem to later when we would have to
	  write this function.</p>

	  <p>This is a very powerful way to use the abstraction
	  mindset even when just working on the high-level programming
	  layer:
	  <ul>
	    <li>Take your problem, figure out a set of functions that,
	    if you wrote them, would make the problem solvable</li>
	    <li>Solve the problem using these functions</li>
	    <li>Then go and write those functions that you needed.</li>
	  </ul>

	  This scores high marks for readability, as we haven't
	  inserted a bunch of absolute value computation code into the
	  middle of the square root function, so the square root
	  function still looks like the square root algorithm as we
	  wrote it originally.  It also scores high marks for
	  maintainability: If we want more accuracy in our
	  computations, it is relatively easy to see what to change.
	  If we think of a better way of computing absolute values, we
	  can adjust that function independently of the square root
	  code and the square root function will work just the
	  same.  </p>
	  
	  <p>All told, this is nice, clean code.  However, it can be
	  even cleaner.</p>

	  <p><b>Square root, Mark II: </b>ur absolute value function
	  was pretty simple and surely someone else both needed it and
	  wrote it before us, right?  Indeed it is so: Python has a
	  <icode>math</icode> library that includes many common (and
	  some less common) mathematics-related functions ready to
	  use.  The one that computes absolute values is called
	  <icode>math.abs(x)</icode>.  So instead we could have
	  written our square root program using it:

	  <python>import input
import math

def square_root(x):
   s = x/2
   while(math.abs(s*s-x) > 0.000001):
      s = s+x/s
      s = s/2
   return s

x = input.get_num("Enter x")
print(square_root(x))</python>
	  </p>

	  <p><b>Square root, Mark III: </b>But wait!  If you ran the
	  above program you might have noticed that there is a
	  <icode>math.sqrt</icode> function.  It turns out that "sqrt"
	  is the common abbreviation for "square root".  So in fact
	  the <icode>math</icode> module already came with a function
	  for computing square roots, and we could simply have done: 	  
<python>import input
import math

print(math.sqrt(input.get_num("Enter x")))</python>
	  </p>

	  <p><b>Debrief: </b>This is an important feature of
	  real-world programming and a very attractive feature of
	  high-level programming languages, and especially of popular
	  ones like Python: If you have a problem that is at all
	  common, then because the Python is so widely used, someone
	  has probably already written a function that solves it and
	  packaged it into a module that's ready to use.</p>
	</text>
      </section>
      <section>
	<title>Factorial</title>
	<text>
	  <p>
	    <python>import input
def factorial(x):
   if(x &lt;= 0):
      return 1
   return x*factorial(x-1)
print(factorial(input.get_num("Factorial of: ")))</python>
	  </p>
	</text>
      </section>
      <section>
	<title>Primality testing</title>
	<text>
	  <python>import math
import input
N = input.get_num("See all primes less than: ")
ns = math.range(2,N)
c = 0
while(c &lt; math.sqrt(N)+1):
   i = c+1
   while(i &lt; len(ns)):
      if(ns[i] % ns[c] == 0):
         del ns[i]
      else:
         i = i+1
   c = c+1
print(ns)</python>
	</text>
      </section>
    </section>
    <section>
      <title>Applications</title>
      <text>
      </text>
      <section>
	<title>Search Engine</title>
	<text></text>
      </section>
      <section>
	<title>Game Console</title>
	<text></text>
      </section>
    </section>
    <section>
      <title>Real-life Python versus Simulator Python</title>
      <text>
      </text>
    </section>
    
</section>    
