<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title></title><link rel="stylesheet" type="text/css" href="/text/box.css"><link rel="stylesheet" type="text/css" href="/sim/py/sim.css"><link rel="stylesheet" type="text/css" href="/sim/avr/sim.css"><link rel="stylesheet" type="text/css" href="/sim/bin/sim.css"><link rel="stylesheet" href="/sim/cm/codemirror.css"><link rel="stylesheet" href="/sim/cm/theme/paraiso-light.css"><script type="text/javascript" src="https://code.angularjs.org/1.4.0-rc.2/angular.min.js"></script><script type="text/javascript" src="https://code.angularjs.org/1.4.0-rc.2/angular-cookies.js"></script><script type="text/javascript" src="/text/box.js"></script><script type="text/javascript" src="/sim/cm/codemirror.js"></script><script type="text/javascript" src="/sim/py/expr_ng.js"></script><script type="text/javascript" src="/sim/py/sim.js"></script><script type="text/javascript" src="/sim/avr/sim.js"></script><script type="text/javascript" src="/sim/bin/sim.js"></script></head><body ng-app="app"><div id="super" ng-controller="BoxController"><div class="index_container" ng-if="display_index == true || display_definitions == true || display_login == true || display_pysim == true || display_avrsim == true || display_pyref == true || display_avrref == true || display_binary_expl == true" ng-click="hide_all()"></div><div class="index" ng-if="display_index == true"><h2>Chapter Outline:</h2><div style="margin-left:5px;" class="index_div"><a href="#" ng-click="goto_loc('sec_3')">3: Advanced Programming</a><br><div style="margin-left:5px;" class="index_div"><a href="#" ng-click="goto_loc('sec_3_1')">3.1: Practical Programming</a><br><div style="margin-left:5px;" class="index_div"></div><a href="#" ng-click="goto_loc('sec_3_2')">3.2: Running actual Python code</a><br><div style="margin-left:5px;" class="index_div"></div><a href="#" ng-click="goto_loc('sec_3_3')">3.3: Arrays</a><br><div style="margin-left:5px;" class="index_div"><a href="#" ng-click="goto_loc('sec_3_3_1')">3.3.1: Strings as read-only arrays</a><br><div style="margin-left:5px;" class="index_div"></div><a href="#" ng-click="goto_loc('sec_3_3_2')">3.3.2: Search engine, revisited</a><br><div style="margin-left:5px;" class="index_div"></div></div><a href="#" ng-click="goto_loc('sec_3_4')">3.4: Logical operators</a><br><div style="margin-left:5px;" class="index_div"></div><a href="#" ng-click="goto_loc('sec_3_5')">3.5: Functions</a><br><div style="margin-left:5px;" class="index_div"><a href="#" ng-click="goto_loc('sec_3_5_1')">3.5.1: Composition</a><br><div style="margin-left:5px;" class="index_div"></div><a href="#" ng-click="goto_loc('sec_3_5_2')">3.5.2: Scope</a><br><div style="margin-left:5px;" class="index_div"></div></div><a href="#" ng-click="goto_loc('sec_3_6')">3.6: Library functions</a><br><div style="margin-left:5px;" class="index_div"></div></div></div></div><div class="index" ng-if="display_definitions == true"><h2>Terminology Index:</h2><a href="#" ng-click="goto_loc('def_readability')">readability</a><br><a href="#" ng-click="goto_loc('def_maintainability')">maintainability</a><br><a href="#" ng-click="goto_loc('def_subscript')">subscript</a><br><a href="#" ng-click="goto_loc('def_input (function)')">input (function)</a><br><a href="#" ng-click="goto_loc('def_body (function)')">body (function)</a><br><a href="#" ng-click="goto_loc('def_return value (function)')">return value (function)</a><br><a href="#" ng-click="goto_loc('def_library function')">library function</a></div><div class="super"><?xml-stylesheet href="box.xsl" type="text/xsl"><div class="section"><div id="sec_3"></div><div class="text"><div class="header">3: 
	  Advanced Programming</div></div></div><div class="section"><div id="sec_3_1"></div><div class="text"><div class="header">3.1: 
	  Practical Programming</div><div class="summary"><b>Summary: </b>In the previous chapter, we introduced a simplified
    version of Python in order to communicate the fundamental ideas of
    programming.  In this chapter, we'll explore further features of
    Python that allow us to complete the same tasks a we had in
    chapter 2 more simply. <br><br><b>Definitions: </b><a href="#def_readability">readability</a>, <a href="#def_maintainability">maintainability</a></div><p>In our journey down the tower of abstractions, we are
      currently discussing high-level programming languages--the tool
      with which large-scale systems are built.  The goal of the
      previous chapter was to introduce the basic concepts of
      programming--things like syntax, semantics, the rigidity of a
      programming language, and how to think within its rules to
      accomplish basic tasks.  For this purpose, we introduced a basic
      subset of Python.  </p><p>As our goal is to drill down into the lower layers of
      abstraction rather than give a full introduction to actual
      programming (which is easily a class all on its own), we'll only
      spend this brief chapter talking about more advanced features of
      Python, and then just enough to convince ourselves that Python
      can actually solve the real-world probems we posed in a sensible
      way.  For example, think back to the code that simulated
      search-engine behavior, searching a file for a user-supplied
      string: </p><div class="code"><pre>search_word = "the"
file1_name = "Ode on the death of a favorite cat"
file1_word1 = "twas"
file1_word2 = "on"
file1_word3 = "a"
file1_word4 = "lofty"
file1_word5 = "vases"
file1_word6 = "side"
file2_name = "Elegy written in a country churchyard"
file2_word1 = "the"
file2_word2 = "curfew"
file2_word3 = "tolls"
file2_word4 = "the"
file2_word5 = "knell"
file2_word6 = "of"
file2_word7 = "parting"
file2_word8 = "day"
if(search_word == file1_word1): 
   print(file1_name)
if(search_word == file1_word2): 
   print(file1_name)
if(search_word == file1_word3): 
   print(file1_name)
if(search_word == file1_word4): 
   print(file1_name)
if(search_word == file1_word5): 
   print(file1_name)
if(search_word == file1_word6): 
   print(file1_name)
if(search_word == file2_word1): 
   print(file2_name)
if(search_word == file2_word2): 
   print(file2_name)
if(search_word == file2_word3): 
   print(file2_name)
if(search_word == file2_word4): 
   print(file2_name)
if(search_word == file2_word5): 
   print(file2_name)
if(search_word == file2_word6): 
   print(file2_name)
if(search_word == file2_word7): 
   print(file2_name)
if(search_word == file2_word8): 
   print(file2_name)</pre></div><p>There are many feature of this that would count as
	un-sensible:

	<ul>
	  <li>We aren't actually reading a file--we're pretending we
	  got the words from a file into separate variables.</li>
	  <li>We aren't actually getting user input from a prompt, but
	  instead require users to change the program when they want
	  to search for a different word.</li>
	  <li>If we want to add another word to the file, we have to
	  add a whole new variable and a whole other if block to test
	  that word.</li>
	  <li>We're repeating a lot of similar code.  So if we
	  decided, say, we wanted to print something else along with
	  the name of the file that contained the query word, we'd
	  have to change every single if-block.  Quite the chore.</li>
	  <li>If we had accidentally typoed one of the variable names,
	  we may skip a word from the file and not realise it.</li>
	</ul>
	
	Several of these concerns deal with the unrealistic nature of
	the example, which we'll certainly rectify in this chapter.
	However some of them get at further concerns beyond realism
	and even beyond those of efficiency and scalability that we
	discussed in the previous chapter.  These new concerns start
	to matter more when your code gets very large and has many
	users, but are worth at least thinking about for any code you
	write: Readability and maintainability.</p><p><div id="def_readability" class="definition"></div><b>Readability</b> refers to how
	easy it is to look at the code and both understand what it is
	meant to do and verify that it actually does that.
	Readability does not necessarily mean concision--doing a
	complex task in one really clever line of code may obscure
	what task that line is actually performing.  Breaking it into
	two or three more perspicuous lines may actually improve
	readability.  </p><p><div id="def_maintainability" class="definition"></div><b>Maintainability</b> refers to
	how easy it is to maintain the code.  This includes things
	like:

	<ul>
	  <li>Identifying and fixing a bug.</li>
	  <li>Changing the behavior of the code.</li>
	  <li>Adding a new feature.</li>
	</ul>

	Code is said to be maintainable if it is written in such a way
	that makes these three tasks easy.  </p><p>Our search engine code from the previous chapter fails
	miserably on both of these measures: As far as readability, it
	is relatively easy to figure out what the code means to do,
	but in order to ensure that it actually does what it is
	supposed to without error, we have to (among other things)
	read through every single if block to ensure there are no
	typos in variable names.  Further, as far as maintainability,
	adding another word requires adding three lines of code.
	Adding another file with even just 100 words (the length of a
	short poem) requires 300 new lines to be added!  While we did
	point out that short code is not necessarily more readable,
	code that is performing a relatively simple task shouldn't be
	hundreds of lines.  And thinking about changing the behavior
	of the code, well, imagine changing it to have it print out
	its output in the format:
	
	<div class="code"><pre>"Found a result: [filename]"</pre></div>

	The internal groaning you just experienced speaks for
	itself.</p><p>This is not the fault of our methodology, but of our tools:
	Actual Python has more features than we introduced in the
	previous chapter, and can in fact accomplish this same task in
	maybe five lines of code regardless of how many files you want
	to search.  </p><p>Before we embark on this chapter's brief journey into
	real-world programming, we indulge in one further remark on
	the principles of programming: The four high-level concerns
	that we've discussed: Efficiency, scalability, readability,
	and maintainability, are not independent, and they sometimes
	war against each other.  Sometimes the most efficient way to
	accomplish something is a highly obscure and clever algorithm
	that, when realized in code, obfuscates the purpose of that
	code entirely.  It is also very common in large projects for
	reasonable amounts of efficiency to be sacrificed for the sake
	of having code that can easily be understood and modified in
	the future, say when a new programmer is hired and has to be
	introduced to the existing code that the other programmers
	have written.  </p><p>Real-world programming almost always involves
	<b>trade-offs</b>, where we trade in, for example, a small
	amount of efficiency to make the code much more
	maintainable.</p></div></div><div class="section"><div id="sec_3_2"></div><div class="text"><div class="header">3.2: 
	  Running actual Python code</div><p>For the moment, the only things described in this chapter
	that are supported by the in-browser simulator are the library
	functions we'll describe towards the end.  This means that if
	you want to see the code here in action, you have to use an
	actual Python compiler from a command-line.  Because this
	chapter is in some ways an excursion from our main journey,
	actually doing this is currently outside the scope of the
	text.</p></div></div><div class="section"><div id="sec_3_3"></div><div class="text"><div class="header">3.3: 
	  Arrays</div><div class="summary"><b>Summary: </b>Arrays are a way of storing multiple values in a single
      variable.  The individual values stored in an array can be
      accessed by subscript notation.<br><br><b>Definitions: </b><a href="#def_subscript">subscript</a></div><p>Probably the most notionally offensive example from the
	previous chapter was our program for searching through a file.
	We weren't even really searching through entire files, but
	only through the first lines of the files, and that was
	already incredibly cumbersome.  Imagine how massive a proper
	search program would be if it had to be written this way!</p><p>The method we used in that example was to store all the words
	in all the documents each in its own separate variable.  What
	would be nice is to be able to store all the words for a
	single document in a single variable, but then to be able to
	get each word that is stored individually.  There is in fact a
	way of doing this:
	
	<div class="code"><pre>file1_words = ["twas","on","a","lofty","vases","side"]</pre></div>

	Such a variable is called an array.  All the variables we met
	in the previous chapter were storing one value under one name,
	so if we wanted to store multiple values, we needed to make
	several different variables, all with different names.  But
	when dealing with a huge amount of data, as we expect to when
	making a search engine, this becomes inconvenient.  So we have
	arrays, which let us store multiple values in one variable.
	The syntax for creating an array is

	<div class="code"><pre><i>variable_name</i> = [<i>expression</i>, <i>expression</i>, ...]</pre></div>

	So, for instance, 
	
<div class="code"><pre>x = 4
an_array = ["hello", 2, 9*x, x, "goodbye"]</pre></div>

declares an array with values 

<div class="code"><pre>"hello"
9
36
4
"goodbye"</pre></div>

<div id="def_subscript" class="definition"></div>Once we have this set up, we can access the individual values stored
in the array with the following <b>subscript</b> notation:

<div class="code"><pre>an_array[4]</pre></div>

This accesses entry number 4 in the array.  So if we want to print
this entry, we'd do

<div class="code"><pre>print(an_array[4])</pre></div>

As a result, we see printed: 

<div class="code"><pre>goodbye</pre></div>

Great!  Or is it?  If you were paying attention, you'd notive that
"goodbye" is the 5th entry in the array.  What gives?  In Python (as
in most programming languages that have arrays) the number you put in
the subscript is the offset from the first entry of the array.  So

<div class="code"><pre>an_array[4]</pre></div>

means "start at the first value in the array and go 4 to the right".
So, if instead you want the first word, you would start at the first
word and go 0 to the right, i.e.:

<div class="code"><pre>an_array[0]</pre></div></p><p>An array element such as <div class="icode">an_array[0]</div> is a variable
like any other, so you can use them in expressions or assignments just
like any other variable:

<div class="code"><pre>some_nums = [4,6,99,-1]
some_nums[0] = 5                                  # Now some_nums is [5,6,99,-1]
print(some_nums)                                  # Prints [5,6,99,-1]
print(some_nums[1])                               # Prints 6
some_nums[2] = some_nums[1] * some_nums[2]        # Now some_nums is [5,6,594,-1]
print(some_nums)                                  # Prints [5,6,594,-1]
if(some_nums[0] % 2 == 0):                        # Not true
   print("some_nums starts with an even number!") # Skipped
else:
   print("some_nums starts with an odd number!")  # Prints the string</pre></div>

So we see that we can access the various values stored in the array
using this subscript notation, and any particular value in an array
can be used in an expression or assignment just like any other
variable.  In particular, we know how to modify existing elements of
an array, but what if we want to add elements to the array?  Python
allows you to add arrays with the + operator:

<div class="code"><pre>array1 = [1,2,3]
array2 = [0,-1,-2]
big_array = array1 + array2
print(big_array)</pre></div>

prints 

<div class="code"><pre>[1,2,3,0,-1,-2]</pre></div></p><p>So what if we just want to put the value 4 on the end of the array?  

<div class="code"><pre>array1 = [1,2,3]</pre></div>

We cannot do

<div class="code"><pre>array1[3] = 4</pre></div>

since there is no array1[3].  array1 has only three elements, and so
trying to assign to its fourth will give a logic error.  Instead, we
need to assign array1 to be array1 plus a list containing just the
element 4:

<div class="code"><pre>array1 = [1,2,3]
array1 = array1 + [4]
print(array1)</pre></div>

prints:

<div class="code"><pre>[1,2,3,4]</pre></div></p></div></div><div class="section"><div id="sec_3_3_1"></div><div class="text"><div class="header">3.3.1: 
	  Strings as read-only arrays</div><div class="summary"><b>Summary: </b></div><p>We've actually seen some examples of arrays already, namely
	strings.  If you think about all the things we just learned
	how to do with arrays--inspect and edit individual elements
	and concatenate arrays--these are operations we would equally
	want to be able to do to strings:

<div class="code"><pre>blah = "Hello World!"
print(blah[6])
print(blah[11])</pre></div>

prints 

<div class="code"><pre>W
!</pre></div></p><p>So, for instance, if the user has inputted 5 words, and we want to
find all those words they've inputted that start with "a", we can now
test this, since we know how to access the individual letters of a
word.  For example:

<div class="code"><pre>word = "betrothed"
print(word[0])</pre></div>

prints the first letter--namely, b.  Now we don't want to print the
letter, but to use it in a test.  Recall that a test is something of
the form

<div class="code"><pre><i>expression comparison expression</i></pre></div>

where the comparison we want is clearly == to test if the first letter
of the word is equal to "a".  Recall an expression is either a number,
string, variable, or combination thereof.  Here, we want to use the
first value in the array called word.</p><p>Thus our test will be: 

<div class="code"><pre>word[0] == "a"</pre></div>

and we get: 

<div class="code"><pre>word = "betrothed"
if(word[0] == "a"):
   print(word[0])</pre></div>

which will not print anything, since word[0] is in fact "b".  Now,
putting this together with 5 random words (which will eventually be
replaced with 5 user inputs):

<div class="code"><pre>word1 = "blithe"
word2 = "alphabetic"
word3 = "crocodiles"
word4 = "ate"
word5 = "asparagus"
if(word1[0] == "a"):
   print(word1)
if(word2[0] == "a"):
   print(word2)
if(word3[0] == "a"):
   print(word3)
if(word4[0] == "a"):
   print(word4)
if(word5[0] == "a"):
   print(word5)</pre></div>

This is somewhat reminiscent of our stupid search program, and indeed
we make a slight initial improvement by storing all the words in an
array:

<div class="code"><pre>words = ["blithe","alphabetic","crocodiles","ate","asparagus"]</pre></div></p><p>But now careful--how do we get, say, the third word in this array?
It is the first value in the words array, so it can be accessed like

<div class="code"><pre>words[2]</pre></div>

Indeed: 

<div class="code"><pre>words = ["blithe","alphabetic","crocodiles","ate","asparagus"]
print(words[2])</pre></div>

prints 

<div class="code"><pre>crocodiles</pre></div></p><p>But now how do we get the first letter of the third word?  The
third word is words[2], and this is a string.  How do we get the first
letter of a string?  By appending [0] to the name of the string.  This
string is called words[2], so indeed we can do:

<div class="code"><pre>words = ["blithe","alphabetic","crocodiles","ate","asparagus"]
print(words[2][0])</pre></div>

which will print the letter c.  Thus we can modify our code: 

<div class="code"><pre>words = ["blithe","alphabetic","crocodiles","ate","asparagus"]
if(words[0][0] == "a"):
   print(words[0])
if(words[1][0] == "a"):
   print(words[1])
if(words[2][0] == "a"):
   print(words[2])
if(words[3][0] == "a"):
   print(words[3])
if(words[4][0] == "a"):
   print(words[4])</pre></div>

As with the search program, we'll learn how to improve this later.  </p><div class="aside"><b>Aside: </b><p>As a remark, we said that arrays can store any list of values, and that those values can be anything that is allowed in a variable.  But an array is allowed in a variable!  So can we store an array with arrays as its values?  The answer is "yes", and this is in fact what we just did above.  But we can be more direct about it: 

<div class="code"><pre>a_big_array = [[1,2,3],[99,-5],[1,2,-1,0,0]]</pre></div>

Then to access the first value of the second array, we can do: a_big_array[1][0].  Recall that a_big_array[1] is the second value in a_big_array, which in this case is [99,-5].  So a_big_array[1] is itself an array, and to get its first value, we append [0].  </p>

<p>This is called a 2-dimensional array.  So, for example, if you wanted to store the state of a tic-tac-toe game, you could store: 

<div class="code"><pre>board = [["X","O","_"],["_","X","O"],["_","_","_"]]</pre></div>

and you could print the board with: 

<div class="code"><pre>print(board[0][0] + board[0][1] + board[0][2])
print(board[1][0] + board[1][1] + board[1][2])
print(board[2][0] + board[2][1] + board[2][2])</pre></div>

which prints

<div class="code"><pre>XO_
_XO
___</pre></div>
</p>

</div></div></div><div class="section"><div id="sec_3_3_2"></div><div class="text"><div class="header">3.3.2: 
	  Search engine, revisited</div><p>Now that we have a basic mechanism for storing the words in
	our files in the search engine example, let us go through an
	example of searching one of them.  </p><p>Recall we could store the words in an array like: 
	
	  <div class="code"><pre>file1_words = ["twas","on","a","lofty","vases","side"]</pre></div>

	  Now we have an input word like

	  <div class="code"><pre>search_word = "the"</pre></div>

	  and we want to compare it to each word in the array.  Of
	  course, as before, we can do this separately like:

	  <div class="code"><pre>if(file1_words[0] == search_word):
   ...
if(file1_words[1] == search_word):
   ...</pre></div>

          But that would be only marginally better than what we did
	  before.  But observe: All that changes between the various
	  if lines is a number.  So this is basically begging for a
	  while loop with a counter, as we deployed in the previous
	  chapter:

	  <div class="code"><pre>
file1_name = "Ode on the death of a favorite cat"
file1_number_of_words = 6	    
file1_words = ["twas","on","a","lofty","vases","side"]
search_word = "the"
counter = 0
while(counter &lt; file1_number_of_words):
   if(file1_words[counter] == search_word):
      print(file1_name)
   counter = counter + 1
	  </pre></div>

	In fact, we can use the "arrays of arrays" trick to search
	multiple arrays:

	<div class="code"><pre>
number_of_files = 2
file_names = ["Ode on the death of a favorite cat", "Elegy in a county churchyard"]
file_word_counts = [6,8]	    
files = [["twas","on","a","lofty","vases","side"], ["the","curfew","tolls","the","knell","of","parting","day"]]
search_word = "the"
file_counter = 0
while(file_counter &lt; number_of_files):
   word_counter = 0
   while(word_counter &lt; file_word_counts[file_counter]):
      if(files[file_counter][word_counter] == search_word):
         print(file_names[file_counter])
      word_counter = word_counter + 1
   file_counter = file_counter + 1
	</pre></div>
	</p></div></div><div class="section"><div id="sec_3_4"></div><div class="text"><div class="header">3.4: 
	  Logical operators</div><div class="summary"><b>Summary: </b>Before, an if or while statement could only include one
    test at a time.  In fact, there is a way to combine multiple tests
    using logical operators, specifying either that we want all of the
    tests to pass, or that we want any of the tests to pass.</div><p>Another feature of the previous chapter's examples that might have
felt somewhat notionally offensive was the following: In order to
check if player 1 won, we had to check if his score was bigger than
player 2's.  And then, in the event that it was, we then had to have
an inside if block to check whether player 1's score was also higher
than player 3's.  And if that held true as well, then we could finally
declare player 1 the winner:

<div class="code"><pre>if(player1_score &gt; player2_score):
   if(player1_score &gt; player3_score):
      print("PLAYER 1 WINS")
</pre></div>

One might hope that instead, we can just test two things at once using
something like:

<div class="code"><pre>if(player1_score &gt; player2_score and player1_score &gt; player3_score):
   print("PLAYER 1 WINS")</pre></div>

In fact, Python is pleasant enough that literally this actually
works.  More generally, we are allowed to combine the simple tests of
chapter 2 using the logical operators and and or.  So, for instance:

<div class="code"><pre>print("Give me a number 0-10, but no 8s--they taste weird")
x = 4
if(x &gt; 0 and x &lt; 10 and x != 8):
   print("good job!")
else:
   if(x == 8):
      print("Yuck!")
else:
   print("BETWEEN 0 AND 10!")
</pre></div>

Or:

<div class="code"><pre>print("Give me a number, 0 or 1--your choice")
x = 4
if(x == 0 or x == 1):
   print("Thank you, kind human.")
else:
   print("CAN YOU REALLY NOT FOLLOW SIMPLE DIRECTIONS?")</pre></div></p><p>Any combination of multiple tests with your choice of and and or is
valid, but there are some pitfalls:

<div class="code"><pre>print("Give me a positive number, either odd or above 10: ")
x = 4
if(x &gt; 0 and x &gt; 10 or x%2 == 1):
   print("Thank you, kind human.")
else:
   print("CAN YOU REALLY NOT FOLLOW SIMPLE DIRECTIONS?")</pre></div>

This program is meant to accept any integer above 10, but also any odd
number 1-9 as well.  However, this program will actually even accept
-1 as a valid input.  The reason is that ands are grouped together
before <div class="icode">or</div>s.  Put another way, the test could
equivalently have been written:

<div class="code"><pre>(x &gt; 0 and x &gt; 10) or x%2 == 1</pre></div>

So when confronted with x = -1, it goes:

<div class="code"><pre>
(-1 &gt; 0 and -1 &gt; 10) or -1 % 2 == 1
   THIS IS FALSE        THIS IS TRUE
</pre></div>
And so since one of the tests is true, the combined test has a value
of true.</p><p>To fix it, we can clarify our meaning by using parentheses:

<div class="code"><pre>print("Give me a positive number, either odd or above 10: ")
x = 4
if(x &gt; 0 and (x &gt; 10 or x%2 == 1)):
   print("Thank you, kind human.")
else:
   print("CAN YOU REALLY NOT FOLLOW SIMPLE DIRECTIONS?")</pre></div>
</p></div></div><div class="section"><div id="sec_3_5"></div><div class="text"><div class="header">3.5: 
	  Functions</div><div class="summary"><b>Summary: </b>Functions are a way of storing actual code so that it
      can be easily re-used in multiple places in a program.<br><br><b>Definitions: </b><a href="#def_input%20(function)">input (function)</a>, <a href="#def_body%20(function)">body (function)</a>, <a href="#def_return%20value%20(function)">return value (function)</a></div><p>In the previous chapter, we often set up our code to have certain
variables acting as the inputs to that code.  For instance, recall our
factorial code:

<div class="code"><pre>input = 50
answer = 1
counter = 2
while(counter &lt;= input):
   answer = answer * counter
   counter = counter + 1
print(answer)</pre></div>

The advantage of this was that if we wanted to compute instead 60!, we
could just change the first line to

<div class="code"><pre>input = 60</pre></div>

and it would happen.  But if in our code we want to compute first the
factorial of 50 and then later that of 90, say, we'll have to have
this same code appearing twice, like:

<div class="code"><pre>input = 50
answer = 1
counter = 2
while(counter &lt;= input):
   answer = answer * counter
   counter = counter + 1
print(answer)
...
input = 90
answer = 1
counter = 2
while(counter &lt;= input):
   answer = answer * counter
   counter = counter + 1
print(answer)</pre></div>

This is unpleasant for a lot of reasons.  If in the future we discover
a subtle bug in our factorial code, or even just a faster way to
compute factorials, then we'll have to change our code in two places
rather than one, and will have to be careful to make the same changes
to both bits of code.</p><p>This is redolent of the situation we had with variables--if we have
some value, we don't want to recompute it anew each time we want to
use it.  Instead, we compute it once, give it a name, and then can
access it at any time in the future just by using that name.</p><p>The idea of a function is to do the same thing again, except for
code.  That is, we can give a bunch of code a name, and then whenever
we want to use it, we can just run it by using its name.</p><p>The actual syntax for doing this is a little more complicated
than for variables, however.  For one thing, blocks of code like the
above have certain variables that are acting as inputs, and others
that are acting as outputs.  And when we use the code's name to run
it, we want to be able to tell it what values to use for inputs, and
where to store the outputs.</p><p>If we've managed to name the above code factorial, then to compute 50!, we should be able to say

<div class="code"><pre>factorial(50)</pre></div>

if we want to store this in some variable called x, then we can do

<div class="code"><pre>x = factorial(50)</pre></div></p><p>In order to do this, we set up the above code in the following way: 

<div class="code"><pre>def <i>function_name</i>(<i>variable_name</i>):
   <i>[lines of code that comprise the function]</i>
   return <i>expression</i></pre></div>
 
<div id="def_input (function)" class="definition"></div>The variable named in the parentheses
after the function name is called the <b>input</b> to the
function.  Whenever the function is run, this variable can be
given a new value, which can be used inside the function.  <div id="def_body (function)" class="definition"></div>The indented lines after the function
definition are called the function's <b>body</b>.  <div id="def_return value (function)" class="definition"></div>The expression in the final line will
be the output of this function--called its <b>return value</b>.
</p><p>A function name may be anything that a variable name could be.  </p><p>To cause the functionto run, then, we simply use the function's
name like:

<div class="code"><pre>function_name(<i>expression</i>)</pre></div></p><p>The function's input variable will be set to the value of the
expression, and then the code in the function will be run.  When it
reaches the a return line, the return value will be used as the value
of this function call.  That is, this function call is actually a new
kind of expression, whose value is the return value of the function.
</p><p>That was rather a mouthful, so let's go through it slowly with an example: 

<div class="code"><pre>def mogrify(x):
   y = x+1
   return 5*y+9*x*x
z = mogrify(2)
print(z)</pre></div>

So the function is named mogrify, and its input is named x.  Then when we run the line 

<div class="code"><pre>z = mogrify(2)</pre></div>

This does as described above:

<ol><li>It sets the input variable to the expression specified (in
this case 2).  So since the input variable was called
<div class="icode">x</div>, it sets x to be 2.  </li>

<li>Then it runs the code in the function body.  In this case, it runs
the line <div class="icode">y = x + 1</div>.  Since x was 2, this sets y to be
3.</li>

<li> Finally, when it reaches the a return line, the return value will
be used as the value of this function call.  The line z = mogrify(2)
is an assignment.  So the return value of mogrify(2) is getting
assigned to the variable z.  Which value is it?  According to step 2,
it is the return value of the function call--in this case,
<div class="icode">5*y+9*x*x</div>, or just 51.
</li></ol>

So the program above will print 51.  </p><p>Some bits of code require more than one value as input.  To turn
these into functions, we simply specify more input variables,
separated by commas.  For instance, if we want to specify two points
on a line and want to compute the distance between them, we can have
easily just subtract them.  However, we have to be careful about what
order we do this in.  For instance, if the first point is 3 and the
second is 5, then the distance is 2, which is the second point minus
the first.  But if the second were instead 2, we would have to
subtract in the other order to get the correct answer of 1.  So we use
an if statement as follows (in this example, say the points are -1 and
6):

<div class="code"><pre>point1 = -1
point2 = 6
if(point1 &lt; point2): 
   answer = point2-point1
else:
   answer = point1-point2
print(answer)</pre></div></p><p>But if we're going to be doing this often, maybe we want it in a function.  Once again, the inputs are relatively clear--point1 and point2--and the output is once again perspicuously called answer.  So: 

<div class="code"><pre>def line_distance(point1, point2):
   if(point1 &lt; point2): 
      answer = point2-point1
   else:
      answer = point1-point2
   return answer</pre></div>

Then if later we call 

<div class="code"><pre>d = line_distance(3,5)</pre></div>

we will start executing the first line of the function with point1 set
to 3 and point2 set to 5.  Then, because point1 is less than point2,
the if block will be executed, setting answer to point2-point1,
i.e., 2, and the else block will be ignored.  Finally the return value
of the function will be set to answer, i.e., to 2.  And so when we say
d = line_distance(3,5), as we stated earlier, the function call
itself--i.e., the line_distance(3,5) bit--is equal to the return value.
Thus d is assigned the value 2.</p></div></div><div class="section"><div id="sec_3_5_1"></div><div class="text"><div class="header">3.5.1: 
	  Composition</div><div class="summary"><b>Summary: </b>Since a function call is an expression, and the input
	to a function call must be an expression, we can use a
	function call as an input to another function call.  This is
	technically nothing new, but it is one of the confusing points
	of functions and so bears some discussion all on its
	own.</div><p>As we've described above, a function call, when it
	  appears in an expression, is treated as being whatever value
	  the function returns.  So, for instance,

	  <div class="code"><pre>def f(x):
   y = x*x
   return x + y*y
print("I'm going to compute something!")
print(2*f(3))</pre></div>

	  Let us consider that last line and how it makes sense: it is
	  a print line.  If we look at our chart, we see that inside a
	  print() is allowed only an expression.  So the question then
	  is: is 2*f(3) a valid expression and, if so, what is its
	  value?</p><p>Well, an expression is supposed to be a number, string,
	  variable, function call (our new addition to the expression
	  family), or combination thereof using operators +, *, -, /,
	  %.  This indeed is a combination of a number and a function
	  call using the operator *, so it is a valid expression.</p><p>Now what is this expression's value?  As we've seen in the
	  previous section, the way to determine this is to break off
	  from the flow of the program into a sort of sub-flow, where
	  we only consider the function call and step through the
	  function with its own private variables:</p><table>
	    <tr><td>Current line</td><td>Why we went to this line</td><td>Variables after current line runs</td><td>Output so far</td></tr>

	    <tr>
	      <td><div class="icode">def f(x):</div></td>
	      <td>
		It was the first line of the program
	      </td>
	      <td>
		(none)
	      </td>
	      <td>
		(none)
	      </td>
	    </tr>

	    <tr>
	      <td><div class="icode">print("I'm going to compute something!")</div></td>
	      <td>
		The previous lines just defined the function.  Now
		that the function has been defined, we advance to the
		first line after this.
	      </td>
	      <td>(none)
	      </td>
	      <td>
		<div class="icode">"I'm going to compute something!"</div>
	      </td>
	    </tr>
	    <tr>
	      <td>
		<div class="icode">print(2*f(3))</div>
	      </td>
	      <td>
		It was the next line
	      </td>
	      <td>
		<div class="icode">x = 3</div>
	      </td>
	      <td>
		  <div class="icode">"I'm going to compute something!"</div>
	      </td>
	    </tr>
	    <tr>
	    <td><div class="icode">   y = x*x</div></td>
	    <td>
	      We just called the function f, so we go to its first line
	    </td>
	    <td>
	      <div class="icode">x = 3, y = 9</div>
	    </td>
	    <td>
	      <div class="icode">"I'm going to compute something!"</div>
	    </td>
	  </tr>
	  <tr>
	    <td>
	      <div class="icode">return x + y*y</div>
	    </td>
	    <td>
	      It was the next line
	    </td>
	    <td>
	      <div class="icode">x = 3, y = 9</div>
	    </td>
	    <td>
	      
	      <div class="icode">"I'm going to compute something!"</div>
	    </td>
	  </tr>
	  <tr>
	    <td>
	      <div class="icode">print(2*f(3))</div>
	    </td>
	    <td>
	      Now that we know the value of <div class="icode">f(3)</div>, we
	      return to the line that called it, fresh with the
	      knowledge that (in this case), <div class="icode">f(3) = 84</div>
	    </td>
	    <td>
	      (none)
	    </td>
	    <td>
	      <div class="icode">"I'm going to compute something!"<br>84</div>
	    </td>
	  </tr>
	  </table><p>In this example the single-stepping was especially simple,
	  and perhaps we could have understood by eye what would
	  happen, but this mechanical breakdown of how function calls
	  work becomes especially important when we have multiple
	  functions being called on the same line, sometimes inside
	  each other.</p><p>For instance, it would not be unheard of in a mathematics
	  course (in particular, the following is not Python code) to
	  see functions like:

	  <div class="code"><pre>f(x) = x^2+1
g(x) = x/13-1
h(x) = 77+x</pre></div>

	  and then to have to compute

	  <div class="code"><pre>f(2*g(h(0)+1))</pre></div>

	  You may already know how to do this intuitively (or possibly
	  not--this is one of the things that trips some people up),
	  but if we're going to do similar things with a computer,
	  we're going to have to understand somewhat mechanically how
	  these things can be done.  So let's take this example.</p><p>It is clearly f of something, but before we can start
	  plugging anything into f, we have to figure out: it is f of
	  what?  Well, we're plugging in 2*g(h(0)+1).  But to compute
	  this, we need to know g(h(0)+1).</p><p>OK, what is g(h(0)+1)?  It's g of something, but before we
	  can plug into g, we have to compute what we're plugging
	  in--in this case, h(0)+1.  And to compute that, we need to
	  know h(0).</p><p>So what is h(0)?  It is 77+0 = 77.  Good.</p><p>So now we can start to go backward:</p><p>We needed previously to know g(h(0)+1).  And now that we
	  know h(0), we know this is g(77+1) = g(78).  And g(78) we
	  can compute by plugging in and we get 78/13-1 = 5 - 1 = 4.</p><p>Before that, we needed to know f(2*g(h(0)+1)).  Now that
	  we know g(h(0)+1) is just 4, we know that this is f(2*4) =
	  f(8), which we can again compute by plugging in: f(8) =
	  8^2+1 = 65.  So the answer is 65.</p><p>This example was, as problems from maths class tend to be,
	  contrived.  But the principle we saw when solving it is one
	  that we'll need now, namely that the first actual function
	  we evaluated was the one that was furthest inside--h(0).
	  Then, once we had that, we could compute what we were
	  plugging into g, and so we computed g(78).  Then, once we
	  had that, we finally knew what we were plugging into f, and
	  so we computed f(8).</p><p>This composition of functions happens all the time in
	  programming, and allows you to express certain things very
	  concisely, provided you can keep your head on straight well
	  enough to do it correctly.</p></div></div><div class="section"><div id="sec_3_5_2"></div><div class="text"><div class="header">3.5.2: 
	  Scope</div><div class="summary"><b>Summary: </b>Variables defined in a function are destroyed (or
	revert to their previous values) once the function
	returns.</div><p>There is some slight danger here regarding variables that
	  were created inside functions:

	  <div class="code"><pre>def f(x):
   y = 1
   return x + y
print(f(2))
print(y)</pre></div>

	  We might expect that when we call f(2) on line 4, we then go
	  into the function which, among other things, creates the
	  variable y with value 1.  Then, when we go to print y on
	  line 5, we should merrily see the value 1 as we expect.
	  Instead, what we see is a logic error that the variable
	  <div class="icode">y</div> was not defined.  The issue, most
	  basically, is that variables that were created inside
	  functions don't continue to exist once the function
	  finishes.</p><p>So our expectation was:</p><table><tr><td>Current line</td><td>
	  Why we went to this line</td><td>
	  Variables after current line runs</td><td>
	  Output so far</td></tr><tr>
	  <td><div class="icode">print(f(2))</div></td>
	  <td>It was the first line (after the definition of the function)</td>
	  <td><div class="icode">x = 2</div> (x is the input variable of the function f, and so
	  when we call f(2), this sets the input variable to 2)</td>
	  <td>
	  </td>
	</tr><tr><td>  
	  <div class="icode">y = 1</div></td><td>
	  We just called the function f, so we go to its first line</td><td>
	  <div class="icode">x = 2<br>y = 1</div></td><td></td></tr><tr>


	  <td><div class="icode">return x + y</div></td>
	  <td>
	  It was the next line
	  </td>
	  <td>
	  
	  <div class="icode">x = 2<br>y = 1</div>
	  </td><td></td></tr><tr>

	  <td><div class="icode">print(f(2))</div></td>
	  <td>
	  We've finished running f, so now we come back here
	  </td>
	  <td>
	  
	  <div class="icode">x = 2<br>y = 1</div>
	  </td>
	  <td>
	  
	  <div class="icode">3</div>
	  </td></tr><tr><td>
	  <div class="icode">print(y)</div></td><td>
	  It was the next line</td><td>
	  <div class="icode">x = 2<br>
	  y = 1</div></td><td>
	  <div class="icode">3<br>1</div></td></tr></table><p>Whereas what actually happens is:</p><table><tr><td>Current line</td><td>
	  Why we went to this line</td><td>
	  Variables after current line runs</td><td>
	  Output so far</td></tr><tr>
	  <td><div class="icode">print(f(2))</div></td>
	  <td>It was the first line (after the definition of the function)</td>
	  <td><div class="icode">x = 2</div> (x is the input variable of the function f, and so
	  when we call f(2), this sets the input variable to 2)</td>
	  <td>
	  </td>
	</tr><tr><td>  
	  <div class="icode">y = 1</div></td><td>
	  We just called the function f, so we go to its first line</td><td>
	  <div class="icode">x = 2<br>y = 1</div></td><td></td></tr><tr>


	  <td><div class="icode">return x + y</div></td>
	  <td>
	  It was the next line
	  </td>
	  <td>
	  
	  (Variables from inside the function body no longer exist)
	  </td><td></td></tr><tr>

	  <td><div class="icode">print(f(2))</div></td>
	  <td>
	  We've finished running f, so now we come back here
	  </td>
	  <td>(none)
	  </td>
	  <td>
	  
	  <div class="icode">3</div>
	  </td></tr><tr><td>
	  <div class="icode">print(y)</div></td><td>
	  It was the next line</td><td>
	  (none)</td><td>
	  <div class="icode">3<br>[error message]</div></td></tr></table><p>But what if the variable existed before the function was
	  called?</p><div class="code"><pre>def f(x):
   y = 1
   return x + y
y = 2
print(f(3))
print(y)</pre></div><p>It turns out that this prints</p><div class="code"><pre>4
2</pre></div><p>But surely what should have happened is that y got created
	  on line 4.  Then we called the function, which, among other
	  things, modifies y to have value 1.  Then later when we
	  print y, it should have value 1, yes?</p><p>So now we get to what is actually happening with variables
	  in functions, which is that every time a function is called,
	  it gets its own environment, or set of variables that is
	  independent from and doesn't affect the variables either
	  outside the function or in future calls to the function.  So
	  we can in fact more accurately picture what's happening
	  thus:</p><table><tr><td>Current line</td><td>
	  Why we went to this line</td><td>
	  Variables after current line runs</td><td>
	  Output so far</td></tr><tr>
	  <td>y = 2</td>
	  <td>It was the first line (after the definition of the function)</td>
	  <td>y = 2</td>
	  <td>
	  </td>
	</tr><tr>
	  <td><div class="icode">print(f(3))</div></td>
	  <td>
	  It was the next line
	  </td>
	  <td>
	  
	  x = 3
	  y = 2
	  </td>
	  <td>
	    </td></tr><tr><td colspan="4">Call to the function f with
	    argument value 3</td></tr><tr>
	  <td><div class="icode">y = 1</div></td><td>
	  We just called the function f, so we go to its first line</td><td>
	  x = 3
	  y = 1</td><td></td></tr>
	<tr>
	  <td><div class="icode">return x + y</div></td><td>
	  It was the next line</td><td>
	  x = 3
	  y = 1</td><td></td></tr>
	  <tr><td colspan="4">f ends now with a return value of
	  4</td></tr>
	  
	<tr>
	  <td><div class="icode">print(f(3))</div></td><td>
	  We now return to the line that called the function with the
	  return value of the function</td><td>
	  y = 2 (The function is over, so any changes it made to any
	  variables are discarded and any variables that existed
	  before the function call retain their previous values</td><td><div class="icode">4</div></td>
	</tr>
	<tr>
	  <td><div class="icode">print(y)</div></td><td>
	  It was the next line</td><td>
	  y = 2</td><td><div class="icode">4
2</div></td>
	</tr>

	</table></div></div><div class="section"><div id="sec_3_6"></div><div class="text"><div class="header">3.6: 
	  Library functions</div><div class="summary"><b>Summary: </b>Now that we know about functions, we can use some
      functions that come pre-packaged with Python (or otherwise).
      These are called library functions. <br><br><b>Definitions: </b><a href="#def_library%20function">library function</a></div><p>Functions are useful to us when writing our programs
	because they help us organise our code more nicely.  But one
	of the great advantages of Python is that it comes with many,
	many functions already written that perform various difficult
	tasks.  From displaying graphics to a screen, to playing
	sounds, to getting mouse click information, there is a
	pre-written function for almost everything.  <div id="def_library function" class="definition"></div>These pre-written functions are called
	<b>library functions</b>.  </p><p>Now, one of the things we have conspicuously omitted from
	our explanation of Python to date was input.  This is because
	input is performed mainly using library functions.  So we are
	now ready to introduce various kinds of input functions.  This
	is done in the <b>Answer: </b><br>simulator
	walkthrough (also linked on the sidebar).  Have fun!</p></div></div></div></div></body></html>
