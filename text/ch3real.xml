<?xml version="1.0" encoding="ISO-8859-1"?><?xml-stylesheet href="box.xsl" type="text/xsl"?><section number="3">
  <title>Advanced Programming</title>
  <section>
    <title>Practical Programming</title>

    <summary>In the previous chapter, we introduced a simplified
    version of Python in order to communicate the fundamental ideas of
    programming.  In this chapter, we'll explore further features of
    Python that allow us to complete the same tasks a we had in
    chapter 2 more simply. </summary>
    
    <text>
      <p>In our journey down the tower of abstractions, we are
      currently discussing high-level programming languages--the tool
      with which large-scale systems are built.  The goal of the
      previous chapter was to introduce the basic concepts of
      programming--things like syntax, semantics, the rigidity of a
      programming language, and how to think within its rules to
      accomplish basic tasks.  For this purpose, we introduced a basic
      subset of Python.  </p>
      
      <p>As our goal is to drill down into the lower layers of
      abstraction rather than give a full introduction to actual
      programming (which is easily a class all on its own), we'll only
      spend this brief chapter talking about more advanced features of
      Python, and then just enough to convince ourselves that Python
      can actually solve the real-world probems we posed in a sensible
      way.  For example, think back to the code that simulated
      search-engine behavior, searching a file for a user-supplied
      string: </p>

      <code>search_word = &quot;the&quot;
file1_name = &quot;Ode on the death of a favorite cat&quot;
file1_word1 = &quot;twas&quot;
file1_word2 = &quot;on&quot;
file1_word3 = &quot;a&quot;
file1_word4 = &quot;lofty&quot;
file1_word5 = &quot;vases&quot;
file1_word6 = &quot;side&quot;
file2_name = &quot;Elegy written in a country churchyard&quot;
file2_word1 = &quot;the&quot;
file2_word2 = &quot;curfew&quot;
file2_word3 = &quot;tolls&quot;
file2_word4 = &quot;the&quot;
file2_word5 = &quot;knell&quot;
file2_word6 = &quot;of&quot;
file2_word7 = &quot;parting&quot;
file2_word8 = &quot;day&quot;
if(search_word == file1_word1): 
   print(file1_name)
if(search_word == file1_word2): 
   print(file1_name)
if(search_word == file1_word3): 
   print(file1_name)
if(search_word == file1_word4): 
   print(file1_name)
if(search_word == file1_word5): 
   print(file1_name)
if(search_word == file1_word6): 
   print(file1_name)
if(search_word == file2_word1): 
   print(file2_name)
if(search_word == file2_word2): 
   print(file2_name)
if(search_word == file2_word3): 
   print(file2_name)
if(search_word == file2_word4): 
   print(file2_name)
if(search_word == file2_word5): 
   print(file2_name)
if(search_word == file2_word6): 
   print(file2_name)
if(search_word == file2_word7): 
   print(file2_name)
if(search_word == file2_word8): 
   print(file2_name)</code>

	<p>There are many feature of this that would count as
	un-sensible:

	<ul>
	  <li>We aren't actually reading a file--we're pretending we
	  got the words from a file into separate variables.</li>
	  <li>We aren't actually getting user input from a prompt, but
	  instead require users to change the program when they want
	  to search for a different word.</li>
	  <li>If we want to add another word to the file, we have to
	  add a whole new variable and a whole other if block to test
	  that word.</li>
	  <li>We're repeating a lot of similar code.  So if we
	  decided, say, we wanted to print something else along with
	  the name of the file that contained the query word, we'd
	  have to change every single if-block.  Quite the chore.</li>
	  <li>If we had accidentally typoed one of the variable names,
	  we may skip a word from the file and not realise it.</li>
	</ul>
	
	Several of these concerns deal with the unrealistic nature of
	the example, which we'll certainly rectify in this chapter.
	However some of them get at further concerns beyond realism
	and even beyond those of efficiency and scalability that we
	discussed in the previous chapter.  These new concerns start
	to matter more when your code gets very large and has many
	users, but are worth at least thinking about for any code you
	write: Readability and maintainability.</p>

	<p><def term="readability"><b>Readability</b> refers to how
	easy it is to look at the code and both understand what it is
	meant to do and verify that it actually does that.
	Readability does not necessarily mean concision--doing a
	complex task in one really clever line of code may obscure
	what task that line is actually performing.  Breaking it into
	two or three more perspicuous lines may actually improve
	readability.  </def></p>
	
	<p><def term="maintainability"><b>Maintainability</b> refers to
	how easy it is to maintain the code.  This includes things
	like:

	<ul>
	  <li>Identifying and fixing a bug.</li>
	  <li>Changing the behavior of the code.</li>
	  <li>Adding a new feature.</li>
	</ul>

	Code is said to be maintainable if it is written in such a way
	that makes these three tasks easy.  </def></p>
	
	<p>Our search engine code from the previous chapter fails
	miserably on both of these measures: As far as readability, it
	is relatively easy to figure out what the code means to do,
	but in order to ensure that it actually does what it is
	supposed to without error, we have to (among other things)
	read through every single if block to ensure there are no
	typos in variable names.  Further, as far as maintainability,
	adding another word requires adding three lines of code.
	Adding another file with even just 100 words (the length of a
	short poem) requires 300 new lines to be added!  While we did
	point out that short code is not necessarily more readable,
	code that is performing a relatively simple task shouldn't be
	hundreds of lines.  And thinking about changing the behavior
	of the code, well, imagine changing it to have it print out
	its output in the format:
	
	<code>"Found a result: [filename]"</code>

	The internal groaning you just experienced speaks for
	itself.</p>

	<p>This is not the fault of our methodology, but of our tools:
	Actual Python has more features than we introduced in the
	previous chapter, and can in fact accomplish this same task in
	maybe five lines of code regardless of how many files you want
	to search.  </p>

	<p>Before we embark on this chapter's brief journey into
	real-world programming, we indulge in one further remark on
	the principles of programming: The four high-level concerns
	that we've discussed: Efficiency, scalability, readability,
	and maintainability, are not independent, and they sometimes
	war against each other.  Sometimes the most efficient way to
	accomplish something is a highly obscure and clever algorithm
	that, when realized in code, obfuscates the purpose of that
	code entirely.  It is also very common in large projects for
	reasonable amounts of efficiency to be sacrificed for the sake
	of having code that can easily be understood and modified in
	the future, say when a new programmer is hired and has to be
	introduced to the existing code that the other programmers
	have written.  </p>
	
	<p>Real-world programming almost always involves
	<b>trade-offs</b>, where we trade in, for example, a small
	amount of efficiency to make the code much more
	maintainable.</p>
      </text>
    </section>
    <section>
      <title>Running actual Python code</title>
      <text>
	<p>For the moment, the only things described in this chapter
	that are supported by the in-browser simulator are the library
	functions we'll describe towards the end.  This means that if
	you want to see the code here in action, you have to use an
	actual Python compiler from a command-line.  Because this
	chapter is in some ways an excursion from our main journey,
	actually doing this is currently outside the scope of the
	text.</p>
      </text>
    </section>
    <section>
      <title>Arrays</title>
      <summary>Arrays are a way of storing multiple values in a single
      variable.  The individual values stored in an array can be
      accessed by subscript notation.</summary>

      <text>
	<p>Probably the most notionally offensive example from the
	previous chapter was our program for searching through a file.
	We weren't even really searching through entire files, but
	only through the first lines of the files, and that was
	already incredibly cumbersome.  Imagine how massive a proper
	search program would be if it had to be written this way!</p>

	<p>The method we used in that example was to store all the words
	in all the documents each in its own separate variable.  What
	would be nice is to be able to store all the words for a
	single document in a single variable, but then to be able to
	get each word that is stored individually.  There is in fact a
	way of doing this:
	
	<code>file1_words = ["twas","on","a","lofty","vases","side"]</code>

	Such a variable is called an array.  All the variables we met
	in the previous chapter were storing one value under one name,
	so if we wanted to store multiple values, we needed to make
	several different variables, all with different names.  But
	when dealing with a huge amount of data, as we expect to when
	making a search engine, this becomes inconvenient.  So we have
	arrays, which let us store multiple values in one variable.
	The syntax for creating an array is

	<code><i>variable_name</i> = [<i>expression</i>, <i>expression</i>, ...]</code>

	So, for instance, 
	
<code>x = 4
an_array = ["hello", 2, 9*x, x, "goodbye"]</code>

declares an array with values 

<code>"hello"
9
36
4
"goodbye"</code>

<def term="subscript">Once we have this set up, we can access the individual values stored
in the array with the following <b>subscript</b> notation</def>:

<code>an_array[4]</code>

This accesses entry number 4 in the array.  So if we want to print
this entry, we'd do

<code>print(an_array[4])</code>

As a result, we see printed: 

<code>goodbye</code>

Great!  Or is it?  If you were paying attention, you'd notive that
"goodbye" is the 5th entry in the array.  What gives?  In Python (as
in most programming languages that have arrays) the number you put in
the subscript is the offset from the first entry of the array.  So

<code>an_array[4]</code>

means "start at the first value in the array and go 4 to the right".
So, if instead you want the first word, you would start at the first
word and go 0 to the right, i.e.

<code>an_array[0]</code></p>

<p>An array element such as <icode>an_array[0]</icode> is a variable
like any other, so you can use them in expressions or assignments just
like any other variable:

<code>some_nums = [4,6,99,-1]
some_nums[0] = 5                                  # Now some_nums is [5,6,99,-1]
print(some_nums)                                  # Prints [5,6,99,-1]
print(some_nums[1])                               # Prints 6
some_nums[2] = some_nums[1] * some_nums[2]        # Now some_nums is [5,6,594,-1]
print(some_nums)                                  # Prints [5,6,594,-1]
if(some_nums[0] % 2 == 0):                        # Not true
   print("some_nums starts with an even number!") # Skipped
else:
   print("some_nums starts with an odd number!")  # Prints the string</code>

So we see that we can access the various values stored in the array
using this subscript notation, and any particular value in an array
can be used in an expression or assignment just like any other
variable.  In particular, we know how to modify existing elements of
an array, but what if we want to add elements to the array?  Python
allows you to add arrays with the + operator:

<code>array1 = [1,2,3]
array2 = [0,-1,-2]
big_array = array1 + array2
print(big_array)</code>

prints 

<code>[1,2,3,0,-1,-2]</code></p>

<p>So what if we just want to put the value 4 on the end of the array?  

<code>array1 = [1,2,3]</code>

We cannot do

<code>array1[3] = 4</code>

since there is no array1[3].  array1 has only three elements, and so
trying to assign to its fourth will give a logic error.  Instead, we
need to assign array1 to be array1 plus a list containing just the
element 4:

<code>array1 = [1,2,3]
array1 = array1 + [4]
print(array1)</code>

prints:

<code>[1,2,3,4]</code></p>
    </text>
    <section>
      <title>Strings as read-only arrays</title>
      <summary></summary>

      
      <text>
	<p>We've actually seen some examples of arrays already, namely
	strings.  If you think about all the things we just learned
	how to do with arrays--inspect and edit individual elements
	and concatenate arrays--these are operations we would equally
	want to be able to do to strings:

<code>blah = "Hello World!"
print(blah[6])
print(blah[11])</code>

prints 

<code>W
!</code></p>

<p>So, for instance, if the user has inputted 5 words, and we want to
find all those words they've inputted that start with "a", we can now
test this, since we know how to access the individual letters of a
word.  For example:

<code>word = "betrothed"
print(word[0])</code>

prints the first letter--namely, b.  Now we don't want to print the
letter, but to use it in a test.  Recall that a test is something of
the form

<code><i>expression comparison expression</i></code>

where the comparison we want is clearly == to test if the first letter
of the word is equal to "a".  Recall an expression is either a number,
string, variable, or combination thereof.  Here, we want to use the
first value in the array called word.</p>

<p>Thus our test will be: 

<code>word[0] == "a"</code>

and we get: 

<code>word = "betrothed"
if(word[0] == "a"):
   print(word[0])</code>

which will not print anything, since word[0] is in fact "b".  Now,
putting this together with 5 random words (which will eventually be
replaced with 5 user inputs):

<code>word1 = "blithe"
word2 = "alphabetic"
word3 = "crocodiles"
word4 = "ate"
word5 = "asparagus"
if(word1[0] == "a"):
   print(word1)
if(word2[0] == "a"):
   print(word2)
if(word3[0] == "a"):
   print(word3)
if(word4[0] == "a"):
   print(word4)
if(word5[0] == "a"):
   print(word5)</code>

This is somewhat reminiscent of our stupid search program, and indeed
we make a slight initial improvement by storing all the words in an
array:

<code>words = ["blithe","alphabetic","crocodiles","ate","asparagus"]</code></p>

<p>But now careful--how do we get, say, the third word in this array?
It is the first value in the words array, so it can be accessed like

<code>words[2]</code>

Indeed: 

<code>words = ["blithe","alphabetic","crocodiles","ate","asparagus"]
print(words[2])</code>

prints 

<code>crocodiles</code></p>

<p>But now how do we get the first letter of the third word?  The
third word is words[2], and this is a string.  How do we get the first
letter of a string?  By appending [0] to the name of the string.  This
string is called words[2], so indeed we can do:

<code>words = ["blithe","alphabetic","crocodiles","ate","asparagus"]
print(words[2][0])</code>

which will print the letter c.  Thus we can modify our code: 

<code>words = ["blithe","alphabetic","crocodiles","ate","asparagus"]
if(words[0][0] == "a"):
   print(words[0])
if(words[1][0] == "a"):
   print(words[1])
if(words[2][0] == "a"):
   print(words[2])
if(words[3][0] == "a"):
   print(words[3])
if(words[4][0] == "a"):
   print(words[4])</code>

As with the search program, we'll learn how to improve this later.  </p>

<aside><p>As a remark, we said that arrays can store any list of values, and that those values can be anything that is allowed in a variable.  But an array is allowed in a variable!  So can we store an array with arrays as its values?  The answer is "yes", and this is in fact what we just did above.  But we can be more direct about it: 

<code>a_big_array = [[1,2,3],[99,-5],[1,2,-1,0,0]]</code>

Then to access the first value of the second array, we can do: a_big_array[1][0].  Recall that a_big_array[1] is the second value in a_big_array, which in this case is [99,-5].  So a_big_array[1] is itself an array, and to get its first value, we append [0].  </p>

<p>This is called a 2-dimensional array.  So, for example, if you wanted to store the state of a tic-tac-toe game, you could store: 

<code>board = [["X","O","_"],["_","X","O"],["_","_","_"]]</code>

and you could print the board with: 

<code>print(board[0][0] + board[0][1] + board[0][2])
print(board[1][0] + board[1][1] + board[1][2])
print(board[2][0] + board[2][1] + board[2][2])</code>

which prints

<code>XO_
_XO
___</code>
</p>

</aside>

      </text>
    </section>
  </section>
  
  <section>
    <title>Logical operators</title>
    <summary>Before, an if or while statement could only include one
    test at a time.  In fact, there is a way to combine multiple tests
    using logical operators, specifying either that we want all of the
    tests to pass, or that we want any of the tests to pass.</summary>
    
    <text>
<p>Another feature of the previous chapter's examples that might have
felt somewhat notionally offensive was the following: In order to
check if player 1 won, we had to check if his score was bigger than
player 2's.  And then, in the event that it was, we then had to have
an inside if block to check whether player 1's score was also higher
than player 3's.  And if that held true as well, then we could finally
declare player 1 the winner:

<code>if(player1_score > player2_score):
   if(player1_score > player3_score):
      print("PLAYER 1 WINS")
</code>

One might hope that instead, we can just test two things at once using
something like:

<code>if(player1_score > player2_score and player1_score > player3_score):
   print("PLAYER 1 WINS")</code>

In fact, Python is pleasant enough that literally this actually
works.  More generally, we are allowed to combine the simple tests of
chapter 2 using the logical operators and and or.  So, for instance:

<code>print("Give me a number 0-10, but no 8s--they taste weird")
x = 4
if(x > 0 and x &lt; 10 and x != 8):
   print("good job!")
else:
   if(x == 8):
      print("Yuck!")
else:
   print("BETWEEN 0 AND 10!")
</code>

Or:

<code>print("Give me a number, 0 or 1--your choice")
x = 4
if(x == 0 or x == 1):
   print("Thank you, kind human.")
else:
   print("CAN YOU REALLY NOT FOLLOW SIMPLE DIRECTIONS?")</code></p>

<p>Any combination of multiple tests with your choice of and and or is
valid, but there are some pitfalls:

<code>print("Give me a positive number, either odd or above 10: ")
x = 4
if(x > 0 and x > 10 or x%2 == 1):
   print("Thank you, kind human.")
else:
   print("CAN YOU REALLY NOT FOLLOW SIMPLE DIRECTIONS?")</code>

This program is meant to accept any integer above 10, but also any odd
number 1-9 as well.  However, this program will actually even accept
-1 as a valid input.  The reason is that ands are grouped together
before <icode>or</icode>s.  Put another way, the test could
equivalently have been written:

<code>(x > 0 and x > 10) or x%2 == 1</code>

So when confronted with x = -1, it goes:

<code>
(-1 > 0 and -1 > 10) or -1 % 2 == 1
   THIS IS FALSE        THIS IS TRUE
</code>
And so since one of the tests is true, the combined test has a value
of true.</p>

<p>To fix it, we can clarify our meaning by using parentheses:

<code>print("Give me a positive number, either odd or above 10: ")
x = 4
if(x > 0 and (x > 10 or x%2 == 1)):
   print("Thank you, kind human.")
else:
   print("CAN YOU REALLY NOT FOLLOW SIMPLE DIRECTIONS?")</code>
</p>

    </text>
  </section>
  <section>
    <title>Functions</title>
      <summary>Functions are a way of storing actual code so that it
      can be easily re-used in multiple places in a program.</summary>
      
      <text>	
<p>In the previous chapter, we often set up our code to have certain
variables acting as the inputs to that code.  For instance, recall our
factorial code:

<code>input = 50
answer = 1
counter = 2
while(counter &lt;= input):
   answer = answer * counter
   counter = counter + 1
print(answer)</code>

The advantage of this was that if we wanted to compute instead 60!, we
could just change the first line to

<code>input = 60</code>

and it would happen.  But if in our code we want to compute first the
factorial of 50 and then later that of 90, say, we'll have to have
this same code appearing twice, like:

<code>input = 50
answer = 1
counter = 2
while(counter &lt;= input):
   answer = answer * counter
   counter = counter + 1
print(answer)
...
input = 90
answer = 1
counter = 2
while(counter &lt;= input):
   answer = answer * counter
   counter = counter + 1
print(answer)</code>

This is unpleasant for a lot of reasons.  If in the future we discover
a subtle bug in our factorial code, or even just a faster way to
compute factorials, then we'll have to change our code in two places
rather than one, and will have to be careful to make the same changes
to both bits of code.</p>

<p>This is redolent of the situation we had with variables--if we have
some value, we don't want to recompute it anew each time we want to
use it.  Instead, we compute it once, give it a name, and then can
access it at any time in the future just by using that name.</p>

<p>The idea of a function is to do the same thing again, except for
code.  That is, we can give a bunch of code a name, and then whenever
we want to use it, we can just run it by using its name.</p>

<p>The actual syntax for doing this is a little more complicated
than for variables, however.  For one thing, blocks of code like the
above have certain variables that are acting as inputs, and others
that are acting as outputs.  And when we use the code's name to run
it, we want to be able to tell it what values to use for inputs, and
where to store the outputs.</p>

<p>If we've managed to name the above code factorial, then to compute 50!, we should be able to say

<code>factorial(50)</code>

if we want to store this in some variable called x, then we can do

<code>x = factorial(50)</code></p>

<p>In order to do this, we set up the above code in the following way: 

<code>def function_name(input_variable_name):
   [lines of code that comprise the function]
   return expression</code>
 
The expression in the final line will be the output of this function--called its return value.  </p>

<p>A function name may be anything that a variable name could be.  </p>

<p>To invoke the function, then, you may simply use the function's name like: 

<code>function_name(expression)</code></p>

<p>The input variable will be set to equal the value of the expression, and then the code in the function will be run.  When it reaches the a return line, the return value will be used as the value of this function call.  </p>

<p>That was rather a mouthful, so let's go through it slowly with an example: 

<code>def mogrify(x):
   y = x+1
   return 5*y+9*x*x
z = mogrify(2)
print(z)</code>

So the function is named mogrify, and its input is named x.  Then when we run the line 

<code>z = mogrify(2)</code>

This does the steps above: 

<ol><li>Runs the code in the function with the input variable set to the value of the input expression: 

So the code inside the function, namely: 

   y = x+1
   return 5*y+9*x*x

is run, with x set to be 2.  Thus y = 3, and the return value will be 5*3 + 9*2*2 = 51.  

</li><li> When it reaches the a return line, the return value will be used as the value of this function call.  

The line z = mogrify(2) is an assignment.  So mogrify(2) should be some value that is getting assigned to the variable z.  Which value is it?  According to step 2, it is the return value of the function call--in this case, 51.  </li></ol>

So the program above will print 51.  </p>

<p>Some bits of code require more than one value as input.  To turn
these into functions, we simply specify more input variables,
separated by commas.  For instance, if we want to specify two points
on a line and want to compute the distance between them, we can have
easily just subtract them.  However, we have to be careful about what
order we do this in.  For instance, if the first point is 3 and the
second is 5, then the distance is 2, which is the second point minus
the first.  But if the second were instead 2, we would have to
subtract in the other order to get the correct answer of 1.  So we use
an if statement as follows (in this example, say the points are -1 and
6):

<code>point1 = -1
point2 = 6
if(point1 &lt; point2): 
   answer = point2-point1
else:
   answer = point1-point2
print(answer)</code></p>

<p>But if we're going to be doing this often, maybe we want it in a function.  Once again, the inputs are relatively clear--point1 and point2--and the output is once again perspicuously called answer.  So: 

<code>def line_distance(point1, point2):
   if(point1 &lt; point2): 
      answer = point2-point1
   else:
      answer = point1-point2
   return answer</code>

Then if later we call 

<code>d = line_distance(3,5)</code>

we will start executing the first line of the function with point1 set
to 3 and point2 set to 5.  Then, because point1 is less than point2,
the if block will be executed, setting answer to point2-point1,
i.e. 2, and the else block will be ignored.  Finally the return value
of the function will be set to answer, i.e. to 2.  And so when we say
d = line_distance(3,5), as we stated earlier, the function call
itself--i.e. the line_distance(3,5) bit--is equal to the return value.
Thus d is assigned the value 2.</p>

      </text>
      <section>
	<title>Composition</title>
	<summary></summary>
	<text>
	  <p>As we've described above, a function call, when it
	  appears in an expression, is treated as being whatever value
	  the function returns.  So, for instance,

	  <code>def f(x):
	  y = x*x
	  return x + y*y
	  print("I'm going to compute something!")
	  print(2*f(3))</code>

	  Let us consider that last line and how it makes sense: it is
	  a print line.  If we look at our chart, we see that inside a
	  print() is allowed only an expression.  So the question then
	  is: is 2*f(3) a valid expression and, if so, what is its
	  value?</p>

	  <p>Well, an expression is supposed to be a number, string,
	  variable, function call, or combination thereof using
	  operators +, *, -, /, %.  This indeed is a combination of a
	  number and a function call using the operator *, so it is a
	  valid expression.</p>

	  <p>Now what is this expression's value?  As we've seen in the
	  previous section, the way to determine this is to break off
	  from the flow of the program into a sort of sub-flow, where
	  we only consider the function call and step through the
	  function with its own private variables:</p>


	  <table><tr><td>Current line</td><td>Why we went to this line</td><td>Variables after current line runs</td><td>Output so far</td></tr><tr>
	  <td><icode>print("I'm going to compute something!")</icode></td>
	  <td>
	  It was the first line (after the definition of the function)
	  </td>
	  <td>
	  
	  
	  "I'm going to compute something!"
	  </td>
	  <td>
	  <icode>print(2*f(3))</icode>
	  </td>
	  <td>
	  It was the next line
	  </td></tr><tr>
	  <td>
	  "I'm going to compute something!"
	  </td>
	  <td>
	  To evaluate this, we need the return value from the call
	  </td>
	  <td>
	  f(3), so we go to the function f:
	  </td>
	  <td colspan="5">
	  Call to function f with input variable x = 3
	  </td>
	  </tr><tr>
	  

	 
	  <td><icode>   y = x*x</icode></td></tr>
	  <tr>
	  <td>
	  We just called the function f, so we go to its first line
	  </td>
	  </tr>
	  <tr>
	  <td>
	  
	  x = 3
	  y = 9
	  </td>
	  <td>
	  
	  "I'm going to compute something!"
	  </td>
	  </tr><tr>
	  <td>return x + y*y</td>
	  <td>
	  It was the next line
	  </td>
	  <td>
	  x = 3
	  y = 9
	  </td>
	  <td colspan="5">
	  "I'm going to compute something!"  </td></tr><tr><td> f is
	  over now, and has return value 84, so now we can come back,
	  having got the return value of f as 84</td></tr><tr>

	  
	  <td><icode>print(2*f(3))</icode></td>
	  <td>
	  We now have the return value of the function, so we know
	  what f(3) is, namely 84
	  </td>
	  <td>
	  </td>
	  <td>
	  

	    <icode>"I'm going to compute something!"
168</icode>
	  </td>
	  </tr></table>
	  
	  <p>In this example the single-stepping was especially simple,
	  and perhaps we could have understood by eye what would
	  happen, but this mechanical breakdown of how function calls
	  work becomes especially important when we have multiple
	  functions being called on the same line, sometimes inside
	  each other.</p>

	  <p>For instance, it would not be unheard of in a mathematics
	  course to see functions like:

	  <code>f(x) = x^2+1
	  g(x) = x/13-1
	  h(x) = 77+x</code>

	  and then to have to compute

	  <code>f(2*g(h(0)+1))</code>

	  You may already know how to do this intuitively (or possibly
	  not--this is one of the things that can trip students up),
	  but if we're going to do similar things with a computer,
	  we're going to have to understand somewhat mechanically how
	  these things can be done.  So take this example.</p>

	  <p>It is clearly f of something, but before we can start
	  plugging anything into f, we have to figure out: it is f of
	  what?  Well, we're plugging in 2*g(h(0)+1).  But to compute
	  this, we need to know g(h(0)+1).</p>

	  <p>OK, what is g(h(0)+1)?  It's g of something, but before we
	  can plug into g, we have to compute what we're plugging
	  in--in this case, h(0)+1.  And to compute that, we need to
	  know h(0).</p>

	  <p>So what is h(0)?  It is 77+0 = 77.  Good.</p>

	  <p>So now we can start to go backward:</p>

	  <p>We needed previously to know g(h(0)+1).  And now that we
	  know h(0), we know this is g(77+1) = g(78).  And g(78) we
	  can compute by plugging in and we get 78/13-1 = 5 - 1 = 4.</p>

	  <p>Before that, we needed to know f(2*g(h(0)+1)).  Now that
	  we know g(h(0)+1) is just 4, we know that this is f(2*4) =
	  f(8), which we can again compute by plugging in: f(8) =
	  8^2+1 = 65.  So the answer is 65.</p>

	  <p>This example was, as problems from maths class tend to be,
	  contrived.  But the principle we saw when solving it is one
	  that we'll need now, namely that the first actual function
	  we evaluated was the one that was furthest inside--h(0).
	  Then, once we had that, we could compute what we were
	  plugging into g, and so we computed g(78).  Then, once we
	  had that, we finally knew what we were plugging into f, and
	  so we computed f(8).</p>

	  <p>This composition of functions happens all the time in
	  programming, and allows you to express certain things very
	  concisely, provided you can keep your head on straight well
	  enough to do it correctly.</p>
	  
	</text>
      </section>
      <section>
	<title>Scope</title>
	<summary></summary>
	<text>
	  <p>There is some slight danger here regarding variables that
	  were created inside functions:

	  <code>def f(x):
   y = 1
   return x + y
print(f(2))
print(y)</code>

	  We might expect that when we call f(2) on line 4, we then go
	  into the function which, among other things, creates the
	  variable y with value 1.  Then, when we go to print y on
	  line 5, we should merrily see the value 1 as we expect.
	  Instead, what we see is:

	  <code>3
	  Traceback (most recent call last):
	  File "&lt;string>", line 5, in &lt;module>
	  NameError: name 'y' is not defined</code>

	  The 3 is the expected return value of f(2), so that line
	  succeeds, but apparently something bad happens on line 5.
	  The issue, most basically, is that variables that were
	  created inside functions don't continue to exist once the
	  function finishes.</p>

	  <p>So our expectation was:</p>


	  <table><tr><td>Current line</td><td>
	  Why we went to this line</td><td>
	  Variables after current line runs</td><td>
	  Output so far</td></tr><tr>
	  <td>print(f(2))</td>
	  <td>It was the first line (after the definition of the function)</td>
	  <td>x = 2 (x is the input variable of the function f, and so
	  when we call f(2), this sets the input variable to 2)</td>
	  <td>
	  </td>
	</tr><tr><td>  
	  y = 1</td><td>
	  We just called the function f, so we go to its first line</td><td>
	  x = 2
	  y = 1</td><td></td></tr><tr>


	  <td>return x + y</td>
	  <td>
	  It was the next line
	  </td>
	  <td>
	  
	  x = 2
	  y = 1
	  </td><td></td></tr><tr>

	  <td><icode>print(f(2))</icode></td>
	  <td>
	  We've finished running f, so now we come back here
	  </td>
	  <td>
	  
	  x = 2
	  y = 1
	  </td>
	  <td>
	  
	  <icode>3</icode>
	  </td></tr><tr><td>
	  <icode>print(y)</icode></td><td>
	  It was the next line</td><td>
	  x = 2
	  y = 1</td><td>
	  3
	  1</td></tr></table>
	
	  <p>Whereas what actually happens is:</p>



	  <table><tr><td>Current line</td><td>
	  Why we went to this line</td><td>
	  Variables after current line runs</td><td>
	  Output so far</td></tr><tr>
	  <td>print(f(2))</td>
	  <td>It was the first line (after the definition of the function)</td>
	  <td>x = 2 (x is the input variable of the function f, and so
	  when we call f(2), this sets the input variable to 2)</td>
	  <td>
	  </td>
	</tr><tr><td>  
	  y = 1</td><td>
	  We just called the function f, so we go to its first line</td><td>
	  x = 2
	  y = 1</td><td></td></tr><tr>


	  <td>return x + y</td>
	  <td>
	  It was the next line
	  </td>
	  <td>(Variables from the function no longer exist)
	  </td><td></td></tr><tr>

	  <td><icode>print(f(2))</icode></td>
	  <td>
	  We've finished running f, so now we come back here
	  </td>
	  <td>
	  </td>
	  <td>
	  
	  <icode>3</icode>
	  </td></tr><tr><td>
	  <icode>print(y)</icode></td><td>
	  It was the next line</td><td></td><td>
	  3
	  [Error message]</td></tr></table>

	  <p>But what if the variable existed before the function was
	  called?</p>

<code>def f(x):
   y = 1
   return x + y
y = 2
print(f(3))
print(y)</code>

	  <p>It turns out that this prints</p>

	  <code>4
2</code>
	  
	  <p>But surely what should have happened is that y got created
	  on line 4.  Then we called the function, which, among other
	  things, modifies y to have value 1.  Then later when we
	  print y, it should have value 1, yes?</p>

	  <p>So now we get to what is actually happening with variables
	  in functions, which is that every time a function is called,
	  it gets its own environment, or set of variables that is
	  independent from and doesn't affect the variables either
	  outside the function or in future calls to the function.  So
	  we can in fact more accurately picture what's happening
	  thus:</p>

	  

	  <table><tr><td>Current line</td><td>
	  Why we went to this line</td><td>
	  Variables after current line runs</td><td>
	  Output so far</td></tr><tr>
	  <td>y = 2</td>
	  <td>It was the first line (after the definition of the function)</td>
	  <td>y = 2</td>
	  <td>
	  </td>
	</tr><tr>
	  <td><icode>print(f(3))</icode></td>
	  <td>
	  It was the next line
	  </td>
	  <td>
	  
	  x = 3
	  y = 2
	  </td>
	  <td>
	    </td></tr><tr><td colspan="4">Call to the function f with
	    argument value 3</td></tr><tr>
	  <td><icode>y = 1</icode></td><td>
	  We just called the function f, so we go to its first line</td><td>
	  x = 3
	  y = 1</td><td></td></tr>
	<tr>
	  <td><icode>return x + y</icode></td><td>
	  It was the next line</td><td>
	  x = 3
	  y = 1</td><td></td></tr>
	  <tr><td colspan="4">f ends now with a return value of
	  4</td></tr>
	  
	<tr>
	  <td><icode>print(f(3))</icode></td><td>
	  We now return to the line that called the function with the
	  return value of the function</td><td>
	  y = 2 (The function is over, so any changes it made to any
	  variables are discarded and any variables that existed
	  before the function call retain their previous values</td><td><icode>4</icode></td>
	</tr>
	<tr>
	  <td><icode>print(y)</icode></td><td>
	  It was the next line</td><td>
	  y = 2</td><td><icode>4
2</icode></td>
	</tr>

	</table>	  
	</text>
      </section>
    </section>
    
    <section>
      <title>Library functions</title>
      <summary></summary>
      <text>
      </text>
      
      <section>
	<title>Console input/output</title>
	<summary></summary>
	<text>
	</text>
      </section>
      <section>
	<title>Graphics</title>
	<summary></summary>
	<text>
	</text>
      </section>
    </section>
</section>    
