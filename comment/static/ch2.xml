<?xml version="1.0" encoding="ISO-8859-1"?><?xml-stylesheet href="box.xsl" type="text/xsl"?><section number="2">
  <title>Chapter 2</title>
  <section>
    <title>Programming as a means of making systems</title>

    <text>
      
<p>Let us start by situating ourselves within the tower of
abstractions we laid out in the previous chapter: We are trying to
understand computers--that is, devices that perform arithmetic,
logical, memory, and I/O operations.  Specifically, we are trying to
understand two things: </p>

<ul><li>How to build complex systems on top of such a basic-sounding
device--simply put: How to program a computer</li>
<li>How to build a computer</li></ul>

<p>Recall we said that to program such a device, we would provide it
with sequences of commands from its ISA.  But because the ISA provides
only basic commands, we prefer to write commands in a more
human-readable form and then have a mechanical way of translating
those commands into the basic ISA commands that the computer
understands.  A human-readable way of defining what the computer
should do is called a <b>high-level programming language</b>.</p>

<p>In this chapter, we'll discuss the concept of a program and a
programming language in general in 2.2, as well as strategies for
writing effective programs.  Then, starting in 2.3, we'll introduce an
actual programming language: Python, and will walk through the process
of writing Python programs to solve specified problems.  </p>

<p><def term='programming'>Most generally, <b>programming</b> is expressing to the computer 
<ul><li>A sequence of steps for it to perform--also known as a program</li>
<li>specified in language that the computer understands--such a language is called a programming language</li></ul>
</def>

<def term="executing">When the computer subsequently executes the steps you gave it, it is
said to be <b>running</b> or <b>executing</b> the program.  </def></p>

<p>In general, you approach a computer with a human-level problem: You want to find out how much you spend on cookies each month, or maybe you want to make a Pacman clone.  However a computer has no understanding of such things--It does not know what a cookie is and does not come with a command for "play pacman".  But it does (at least, at the level we're thinking about it currently) provide you with a programming language--that is, you can tell it to do certain specific operations that are allowed by the language.  Beyond that, a computer is a machine--if you give it a sequence of commands in a programming language, it very simply does everything listed in that program, and nothing else.  It has no understanding of--let alone sympathy for--its owner's 'intent'.  </p>

<code>A classic parable--"If your husband were a computer": 

"Honey, while you're out, could you stop by the store and buy one
carton of milk?  And if they have eggs, get 6."  

A short time later the husband comes back with 6 cartons of milk.

The wife is perplexed.  "Why did you buy 6 cartons of milk?"

"They had eggs!"</code>

<p>This is the gap that a programmer has to bridge: Taking a high-level problem coming from the real world, and turning it into a sequence of steps that are allowed in a given programming language.  </p>

<p>In this chapter, we'll do three things: 

<ol><li>In 2.2, we'll discuss the first step in crossing this gap: Algorithms.  An algorithm is a human-readable description of computer-friendly steps intended to solve a high-level problem.  There are a few considerations that come into play when designing an algorithm--how "good" is a particular algorithm for solving a problem, and what does "good" even mean for algorithms.  </li>

<li>Then, in 2.3, and 2.4, we'll take the next step: Once we've got the algorithm--the computer-friendly steps that solve the problem--we need the program.  That is, we need to write those steps in a computer-friendly way.  So we'll introduce a specific programming language--Python, talking only about the rules about what instructions are allowed in a valid Python program (also known as Python's syntax, and discussed in 2.4), and what specific valid instructions actually do (Python's semantics, discussed in 2.5).  </li>

<li>Finally, in 2.5 and 2.6, we'll go through examples of ever-increasing complexity that put this whole process together: Starting with a general problem, constructing an algorithm that solves it in a computer's terms, and then turning that algorithm into a program so that the computer can find the actual solutions for us.  </li></ol></p>
    </text>
  </section>


  <section id="5">
    <title>Algorithms: Expressing solutions in human language, but in terms of the computer's primitives</title>
    <summary></summary>

    <text>
      <p>Suppose you've written a computer game, which has 3 players, each of whom has a score.  At the game's end, you'd like to determine a winner.  To a human, looking at the three scores and picking out the largest one is completely straightforward.  After all, "pick the largest of three numbers" seems like a primitive operation in its own right, which we never have to think about breaking down into a more precise, step-by-step procedure.  </p>

<p>However such a step-by-step procedure is exactly what a computer needs in order to accomplish this same goal.  It doesn't have a "find the largest number" operation built-in.  Instead, its available operations are basic: Things like "add two numbers", "compare two numbers", and the like.  </p>

<p>First of all, we know the computer can store numbers.  In fact, as we will see later, you can store numbers under names of your choosing, so suppose we've stored the three players' scores under the names score1, score2, and score3 respectively.  Then a procedure for determining the winner might look like: </p>

<code>If score1 is greater than score2 and score1 is also
greater than score3: Display the text: "PLAYER 1 WINS!"

If not, then if score2 is greater than score1 and score2 is also
greater than score3: Display the text: "PLAYER 2 WINS!"

If not, then if score3 is greater than score1 and score3 is also
greater than score2: Display the text: "PLAYER 3 WINS!"
<caption>An algorithm for determining the winner of a 3-payer game given
the scores</caption></code>

<p>This procedure can now believably be broken down into simple arithmetic operations: Comparing two numbers is an operation the computer can do, and the simple logic operation "if both this and that are true" is another, so indeed, the above does comprise a computer-friendly procedure.  It is not yet a program because it was still written in English, rather than in a language the computer understands, but it is a complete description of computer-friendly steps for accomplishing what we need done.  Recall that such a precisely specified procedure we called an algorithm.  </p>

<p>There are two things that might give you pause about this algorithm as written:  namely, it's handling of ties, and its apparent inefficiency.  </p>

    </text>
    <section>
      <title>Edge-cases</title>
      <summary>Hello</summary>
      <text>
	<p>When you sit down to write an algorithm, you should have
	some understanding of what you can and cannot expect of the
	inputs.  For instance, try to follow through the above
	algorithm if <pre>score1 = 10, score2 = 10, score3 = 7</pre>.
	It doesn't print anything at all!  <def term='edge-case'>Such
	inputs are sometimes called <b>corner-cases</b> or
	<b>edge-cases</b>.  They are not generally what your algorithm
	will have to deal with, but they can still happen in theory,
	and when they do, they can give you a rather bad day if you
	haven't accounted for them.</def> Indeed, failing to deal with
	even a single sneaky corner-case is a common cause of serious
	problems in real-world programming.</p>

	<p>For now, for simplicity, we'll assume the rest of the game
	is set up so that any tie is resolved with a tie-breaker, so
	that in fact, by the time the algorithm above is run, there
	are no remaining ties.  </p>

	<p>This is one perfectly valid way of dealing with
	corner-cases: Just add some further steps that ensure that
	they can honestly never appear.  This decision comes from
	asking the higher-level question of how we in fact want the
	game to work.  If we really don't want there to be ties in the
	end (e.g. we always make it so there are tiebreaker rounds
	until all ties are resolved), then we may do as we suggested.
	But if we actually think ties should be a valid result in our
	game, then we would have to expand our score-comparison
	algorithm to deal with this and detect them.</p>
      </text>
    </section>
    <section>
      <title>Efficiency</title>
      <summary>Hello</summary>
      <text>
	<p>There are two things about this algorithm's inefficiency
	that might offend your sensibilities: We're comparing three
	numbers, so it seems like the number of actual "compare these
	two numbers" operations required shouldn't be too many.  But
	indeed, if score3 happens to be the largest number, then the
	above algorithm will perform this operation 6 times: </p>

	<p>We first compared score1 to score2 and then to score3.
	Since score1 wasn't the largest, we then compared score2 to
	score1 and to score3.  Since score2 was alo not the largest,
	we finally compared score3 to score1 and to score2, and saw
	that score3 was indeed larger than the other two.  This
	intuitively seems a lot more work than your brain is likely
	doing when you simply look at three numbers and spot the
	largest by eye, so it might be worth looking for an improved
	algorithm that will involve less work from the computer.  </p>

	<p>By contrast, consider the following algorithm: </p>

<code>If score1 > score2, then do the following: If score1 > score3,
Display "Player 1 wins", or else display "Player 3 wins!"

Otherwise, do the following: If score2 > score3, Display "Player 2
wins", or else display "Player 3 wins!"<caption>A sligtly more
efficient algorithm for comparing three scores</caption></code>

<p>This algorithm contains three comparisons, but it will only ever perform 2 regardless of inputs.  </p>

<p>(As an aside: It is worth revisiting the question of edge-cases with this improved algorithm, and noting that while our previous algorithm printed nothing in case of a tie, this one may actively print the wrong thing--try it and see!)</p>

      </text>
    </section>
    <section>
      <title>Scalability</title>
      <summary>Hello</summary>
      <text>
<p>There is a related but more subtle concern about the original algorithm, which is: Suppose instead we had 10 players?  Or 100?  What would it look like then?  </p>

<p>The structure of the algorithm was:</p>

<code>First do all the comparisons to see if player 1 won.

If player 1 didn't win, then do all the comparisons to see if player 2
won.

etc.</code>

<p>So in the case of 10 players, it looks like:</p>

<code>If score1 > score2 and score1 > score3 and ... and score1 >
score10, then display "Player 1 wins!"

Otherwise, if score2 > score1 and score2 > score3 and ...

..............</code>

<p>Before, it player 3 won, we had to do 6 whole comparisons to find this out.  Now there are 10 players who might have won, and testing each requires 9 comparisons, so we get a total of 90 comparisons that might have to happen before we can determine a winner!  In general, for N players, we have N*(N-1) comparisons--so for 100 players, that's 9900 comparisons!</p>

<p>These numbers might seem notionally problematic, but it is possible
to assess the actual cost in time and energy to say something
objective: An average computer might say it is "clocked at a 1 GHz".
That means it can do a one billion basic operations every second.  If
you're running a massively multiplayer online game with 10000 players,
then using this algorithm, each winner calculation will take at least
99990000, or roughly one hundred million operations.  With a 1 GHz
computer, we can thus only compute a winner around 10 times per
second.  And if we want to constantly be displaying the current leader
on the screen as the game progresses, this means the game can only
update the display 10 times per second at most (i.e. run the game at
what 10 "frames per second").  But the illusion of smoothness in
gameplay comes from updating the picture on the screen at the very
least 30 times per second, so limiting a game to 10 frames per second
would result in noticeable stuttering and could easily render the game
unplayable.  </p>

<p>Whether scalability is a concern for your particular application is
more a question of your philosophy and ambitions.  If you're really
honestly only ever going to have three players, then reducing 6
operations to 2 on a computer that can perform billions every second,
and putting a lot of effort in to make your program works for
thousands of people at a time when that scale is very far in your
project's future may or may not be the best use of your time right at
the start of such a project.  </p>
      </text>
    </section>
    
  </section>

  <section>
    <title> Python: Expressing algorithms using a programming language</title>
    <text>
      <p>Now we come to the second step in using a computer to solve a
      problem.  We have the algorithm describing the steps the
      computer can take to solve it.  Now we need to write those steps
      in a language the computer understands--a <b>programming
      language</b>.  In this section, we'll be introducing the rules
      governing a specific programming language--Python.  </p>
      
      <p>In this section, we'll provide a basic introduction to the
      language and get you running your first program.  In the
      subsequent sections, we'll introduce the <def term="syntax">
      <b>syntax</b>--that is, what are the rules that determine
      whether the instructions in a program are valid</def>, and the
      <b>semantics</b>--<def term='semantics'> that is, what do the
      various instructions actually do.</def></p>

      <p>In this chapter alone, we will discuss only a subset of
      Python, which will be sufficient accomplish many goals, at the
      price of being less powerful than the whole Python language
      actually us.  In chapter 3 we shall see some of Python's
      advanced features and how they simplify some of the tasks that
      will be slightly cumbersome in this chapter.</p>

      <p>Finally, as with most computer-related things, you can find
      more information on any specific topic with a studied use of
      your favourite search engine.  If you find yourself confused
      about while loops in Python (whatever those are), punching
      'python while loop' or even 'python while loop tutorial' into
      Google will often have an enlightening effect.</p>
    </text>
    <section>
      <title>Running Python</title>
      <summary></summary>
      <text>
	<p>Python is a real-world programming language with many uses
	in the wild.  However, in this chapter, since we're focusing
	on a very small part of the Python language, we will not run
	any code on a real computer.  Rather, we will use the web
	browser to simulate the code being run.  This way, we will get
	to watch what happens, as if in slow-motion, as the code is
	executed, rather than it all happening at once and trying to
	work out or imagine what happened afterward.  </p>

	<p>To get started, you can open the simulator by clicking the
	"Python" link on the sidebar.  If you're the sort of person
	who would rather play the game without first reading the
	rules, a few example programs and challenges are available for
	your perusal from the control panel at the top of the screen.
	</p>

	<p>To use the simulator, you write your program in the text
	box on the right.  When ready, click the "run" button above
	it, whereupon the simulation will be prepared.  At this point,
	no changes to the code can be made until you press the "reset"
	button.  To execute a single line of code, click the "step"
	button.  If you want to run more than one step at a time,
	simply enter how many steps you want the step button to
	advance into the input box to the right of it.  </p>

	<p>As you step through the code, the line that will be
	executed the next time you step is highlighted in the program
	text input by a red arrow that will appear next to that line
	in the left-hand margin.</p>

	<p>While you can write and test any program in this simulator,
	some programs right here in the main text will be embedded in
	a smaller version of the simulator so you can step through the
	examples and see how they work and edit them as you please to
	see how various changes affect the behaviour.  You can always
	restore the original example program by pressing the "original"
	button.  </p>
      </text>
    </section>
    <section>
      <title>A first Python example</title>
      <summary></summary>
      <text>
	<p>There is a famous mathematical problem--known as the 3x+1
	conjecture--that goes as follows: 

<ol><li>Start with any positive integer.  </li>
<li>If it is even, divide it by 2.  If odd, triple it and add one.
</li>
<li>If the result is 1, stop.  Otherwise, go back to the previous
step.</li>
</ol>

For example, we start with 5:</p>

<table>
<tr><td>Current value</td><td>What do we do next?</td></tr>
<tr><td>5</td><td>5 is odd, so triple and add 1 to get...</td></tr>
<tr><td>16</td><td>16 is even, so divide by 2</td></tr>
<tr><td>8</td><td>8 is even, so divide by 2</td></tr>
<tr><td>4</td><td>4 is even, so divide by 2</td></tr>
<tr><td>2</td><td>2 is even, so divide by 2</td></tr>
<tr><td>1</td><td /></tr>
</table>

<p>The conjecture is that we always get down to 1, regardless of our
start input.  We just verified the conjecture starting with x = 5, but
what about other values of x?  We can start doing some, and it's
pretty easy: For x = 25, for example, it goes: 

<code>25, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40,
20, 10, 5, 16, 8, 4, 2, 1</code>

It takes a little while, but we can sort of do it by hand.  However,
for x = 27, if we start, we get the sequence:

<code>27, 82, 41, 124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161,
484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466,
233, 700, 350, 175, 526, 263, 790, 395, 1186, ......</code>

Which looks like it might possibly continue with its fitful growth
forever.  If only we could get a computer to do the tedious work of
running the algorithm for us...</p>

<p>To this end, take the following Python program (don't worry if you
don't understand it yet--all will be explained in time): </p>

<python>x = 27
while(x != 1):
   y = x % 2
   if(y == 0):
      x = x / 2
   else:
      x = 3 * x + 1
   print(x)
print("Done")
</python>

<p>Before we jump into studying this program, let's run it to see what
happens: </p>

<p>[...Instructions for running the program.  Note that it takes a
very long path to get to 1 and that this is weird.]</p>

<p>Now, if you compare this listing to the English language algorithm
description, you notice some similarities, but the Python syntax is
more rigid: The computer runs this program by the code one line at a
time.  After one line is run, it moves on to the next line, unless
some instruction tells it to do otherwise.  </p>

<p>This is a fundamental rule, and should be internalised so you can
get used to understanding programs mechanically: Programs are run one
line at a time.  In particular, understanding a program entails not so
much looking at it as a whole, but understanding what each line does
individually.  Generally, once one line's instruction is completed,
the next instruction to be run is the one on the following line,
except in certain situations in which an instruction can tell the
program to jump to a different line.  For example, the block:
</p>

<code>x = 27
<div class='highlight'>while(x != 1):
	y = x % 2
	if(y == 0):
		x = x / 2
	else:
		x = 3 * x + 1
	print(x)</div>
print("Done!")
</code>

<p>means that all the indented instructions should be repeated as long
as x is not 1 (which is written in Python as x != 1).  In particular,
when we get to the line </p>

<code>x = 27
while(x != 1):
	y = x % 2
	if(y == 0):
		x = x / 2
	else:
		x = 3 * x + 1
	<div style='background-color:green;'>print(x)</div>
print("Done!")
</code>

<p>if x still isn't 1, then we don't go to the next line (which is the end of the program!), but instead jump back to the beginning of the indented "while" block--specifically, to the line </p>

<code>x = 27
while(x != 1):
	<div style='background-color:green;'>y = x % 2</div>
	if(y == 0):
		x = x / 2
	else:
		x = 3*x+1
	print(x)
print("Done!")
</code>

<p>There is a second difference between the English description of the
algorithm and its programmatic realisation, namely that whereas when
describing the algorithm, we had a notion of "the current value of the
number", which in the example took on the values "5, 16, 8, 4, 2, 1".
In the program, we have to give the value a name.  In this program, we
have chosen the name "x".  Such a "named value" is called a variable.
Variables are used whenever we want to store the value of a
computation for later use.</p>

<p>In this program, we have two variables, called "x" and "y", whose stored values get updated as the program progresses.  </p>

<p>Using the rule that a program is run one line at a time, we can
follow along with the program, one line at a time, to see: 
<ol><li>Which lines get executed</li>
<li>What values the variables are storing</li></ol></p>

<table>
<tr><td>Current line</td><td>Why we went to this line</td><td>Variables after current line runs</td><td>Output so far</td></tr>
<tr>	 
<td><pre>x = 27</pre></td>
<td>     It was the next line</td>
<td><pre>x = 27</pre></td>
</tr>    

<tr>	 
<td><pre>while(x != 1):</pre></td>
<td>     It was the next line</td>
<td><pre>x = 27</pre></td>
</tr>    

<tr>	 
<td><pre>   y = x % 2</pre></td>
<td>     x was not 1</td>
<td><pre>x = 27, y = 1</pre></td>
</tr>    

<tr>	 
<td><pre>   if(y == 0):</pre></td>
<td>     It was the next line</td>
<td><pre>x = 27, y = 1</pre></td>
</tr>    

<tr>	 
<td><pre>      x = 3*x+1</pre></td>
<td>     y was not 0</td>
<td><pre>x = 82, y = 1</pre></td>
</tr>    

<tr>	 
<td><pre>	print(x)</pre></td>
<td>     It was the next line</td>
<td><pre>x = 82, y = 1</pre></td>
<td>     82</td>
</tr>    

<tr>	 
<td><pre>y = x % 2</pre></td>
<td>     We reached the end of the while block, but x was not 1, so we go back to the start</td>
<td><pre>x = 82, y = 0</pre></td>
<td>     82</td>
</tr>    

<tr>	 
<td><pre>   if(y == 0):</pre></td>
<td>     It was the next line</td>
<td><pre>x = 82, y = 0</pre></td>
<td>     82</td>
</tr>    

<tr>	 
<td><pre>     x = x / 2</pre></td>
<td>     y was 0</td>
<td><pre>x = 41, y = 0</pre></td>
<td>     82</td>
</tr>    

<tr>	 
<td><pre>print(x)</pre></td>
<td>     We skip the else block because the if condition was true</td>
<td><pre>x = 41, y = 0</pre></td>
<td>     82
<br />   41</td>
</tr>    

<tr>	 
<td><pre>y = x % 2</pre></td>
<td>     We reached the end of the while block, but x was not 1, so we go back to the start</td>
<td><pre>x =41, y = 1</pre></td>
<td>     82
<br />   41</td>
</tr>    

<tr>	 
<td><pre>if(y == 0):</pre></td>
<td>     It was the next line</td>
<td><pre>x = 41, y = 1</pre></td>
<td>     82
<br />   41</td>
</tr>    

<tr>	 
<td><pre>     x = 3*x+1</pre></td>
<td>     y was not 0</td>
<td><pre>x = 124, y = 1</pre></td>
<td>     82
<br />   41</td>
</tr>    

<tr><td><pre>print(x)</pre></td>
<td>It was the next line</td>
<td><pre>x = 124, y = 1</pre></td>
<td>82<br />
41<br />
124</td></tr>
</table>

And so on.
</text>
      
    </section>
    <section>
      <title>Python language summary</title>
      <summary></summary>
      <text>
	<p>We now present a brief summary of all of Python as we'll
	use it in this chapter.  This includes a specification of the
	syntax--the rules that define what is allowed as Python code,
	and the semantics--what the various valid constructs do.  </p>

	<p>The way this specification works is recursive: For example,
	we will first specify that Python code is run one line at a
	time.  So to do something in Python, we have to write a
	sequence of lines.  So then the question is: What is a line?
	In the table below, we see that a line is either an
	'assignment line', 'print line', or a 'flow-control' line.  </p>

	<p>We haven't said what any of these are yet, but behold, they
	show up later in the table!  The table tells us that
	assignment lines are used for computation and for setting
	variables, print lines are for printing things, and
	flow-control lines are for deciding which line to execute
	next.  </p>

	<p>So if we now decide that what we want is to store some
	number in a variable, then we look at the specification for an
	assignment line, since that seems the thing for the job.  It
	says that an assignment line looks like: 

	<pre><i>variable name</i> = <i>expression</i></pre>

	We haven't said what variable names or expressions are, but
	they are also described in the table!</p>

	<p>Looking further down to variable names, we see that a
	variable name can be anything with letters, numbers, and
	underscores, but not starting with a number, and not a Python
	keyword.  So we can decide to call our variable, say, 
	<pre>H3LL0_th3re_</pre>.  </p>

	<p>But what about the expression bit?  Expressions are defined
	in the table as any valid combination of numbers, strings, and
	variables using the basic operations and parentheses for
	grouping.  So if we want to store the value 89*90, we can do
	this like: 

	<pre>H3LL0_th3re_ = 89*90</pre>

	And the fact that we have followed the table tells us that
	this is a valid assignment line which will store the value of
	the expression 89*90--i.e. the number 8010--into a variable
	called H3LL0_th3re_.</p>

	<p>We will discuss each element in greater detail in the next
	section, but place the whole thing in brief here as a
	reference: </p>

	<div ng-include="'sim/py/ref.html'">
	</div>
      </text>
      
    </section>
  </section>

  <section>
    <title>A detailed explanation of Python</title>
    <text>
      <p>We now give a more detailed explanation of the Python
      language elements we introduced above.  For example, in addition
      to providing greater detail about what they are, we provide
      examples and give examples of when to use them.   
      </p>
    </text>
    <section>
      <title>Python syntax</title>
      <summary></summary>
      <text>
	<p>Before we dive too deep into explaining Python, we
	reiterate that while the most interesting part of any
	programming task is always deciding how to match the code to
	the problem, your code must first always conform to proper
	Python syntax or it will not do anything at all.  Happily,
	ensuring proper syntax in your Python is very much the easy
	part, and doesn't even require you to think about or even know
	what your code does.  Much as you can probably tell that the
	phrase "Begone, you ancephalous lummox!" is valid English,
	whereas "Accismus very kerfuffle the, bromnopea in" is not,
	even without knowing the meaning of many of the words
	involved, you do not need to understand Python semantics in
	order to tackle its syntax.</p>

	<p>We can distill from the above table a diagram that
	completely describes Python syntax, and that we can use to
	verify the validity of any program quite easily: </p>
	
	<figure><description>Syntax tree for our subset of Python--the
	ASCII-art thing in the Google doc</description><caption>The
	syntax tree for Python</caption></figure>
	
	<p>To see how this works, let us take our example program from
	the previous section: </p>

<python>x = 27
while(x != 1):
   y = x % 2
   if(y == 0):
      x = x / 2
   else:
      x = 3 * x + 1
   print(x)
print("Done!")</python>

<p>and check line-by-line that it is a valid program: </p>

<code>x = 27 </code>

<p>This first line looks like it must be an assignment.  That means it has to look like </p>

<code><i>variable name</i> = <i>expression</i></code>

<p>Indeed, looking at the rules for variable names, "x" is a valid
variable name.  Further, expressions are defined as numbers, strings,
variables, or combinations thereof.  27 is a number, and hence a valid
expression.  So indeed, this is a valid assignment line.</p>
      
<code>while(x != 1):</code>

<p>This is a while line, so it must look like</p>

<code>while(<i>test</i>): </code>

<p>So we need to check that <pre>x != 1</pre> is a valid test.  A test
has to look like:</p>

<code><i>expression</i> <i>comparison</i> <i>expression</i></code>

<p>and since x is a valid expression (it is a variable name), != is a
valid comparison (as we can see from our list of comparisons), and 1
is a valid expression (it is a number), and since this line is
followed by some indented lines, it is a valid while flow-control
line.</p>

<code>   y = x % 2</code>

<p>This line is indented as it is part of the while loop.  It looks
like an assignment, and indeed, y is a variable name, and x % 2, being
a combination of a variable name (x) and a number (2) using one of the
allowed operators (%), is an expression.  </p>

<code>   if(y == 0):</code>

<p>Much like we checked the while line, this is a valid "if" flow-control line.  In fact, since it has an "else" later, these form a valid if/else flow-control structure: </p>

<code>
   if(y == 0):
      x = x / 2
   else:
      x = 3 * x + 1
</code>

Note that the line following the "if" line is indented by two steps.
The if line is indented once because it is inside the while loop.
Then remember that lines under the if statement have to be indented
not just "three spaces" full stop, but three spaces more than the if
line they are following.  The effect is that the line

<code>      x = x / 2</code>

<p>gets indented using 6 spaces, since it is inside the if, which is inside a while.  </p>

<code>   print(x)</code>

<p>This is a print statement, i.e. something like </p>

<code>print(<i>expression</i>)</code>

<p>and is indeed valid, since x, being a variable name, is a valid expression</p>

<code>print("Done!")</code>

<p>This is another valid print line, since "Done!" is a valid string, and strings are valid expressions.  </p>

<p>So we've checked that this program is syntactically valid.  One final thing to point out about this syntax-checking procedure was its mechanical, recursive nature: Once we identify that, say, the line</p>

<code>x = 3 * x + 1</code>

<p>is an assignment, that means it has to be constructed from a variable
name and an expression.  So we identify the pieces of the line that
should correspond to each of these: x is the variable name, and 3 * x
+ 1 should be the expression.  Then we check the definitions of each
of these: A variable name is any combination of letters, numbers, and
underscores, with certain exceptions.  x is thus a valid variable
name.  Now we check 3 * x + 1 is a valid expression similarly just by
going back to the definition of "expression" in the syntax.</p>


<p>Aside: The fact that our specification of the syntax leads
naturally to a mechanical checking procedure is important.  Since
ultimately, there has to be a program that understands the programming
language in order to turn it into ISA operations, it is natural that
this program be able to take such a specification and follow an
algorithm that generalises our checking procedure.  In your future
computer science studies, you may take a course in designing your own
programming language, where you will make all this precise and
effectual.  </p>

      </text>
    </section>
    <section>
      <title>Assignments</title>
      <summary></summary>
      <text>
<p>Recall that assignments are written 

<code><i>variable name</i> = <i>expression</i></code>

These are how we store and modify the values in variables.  For
instance, the line</p>

<code>x = 2</code>

<p>stores the value 2 in a variable called x.  Then if we later want to use this stored value, we can refer to it by its name, x.  For instance, </p>

<code>y = 2 * x</code>

<p>will store the value 4 into another slot called y.  We've seen a couple of slightly trickier variants of this already.  For example, we can update variables using themselves: </p>

<python>x = 2
x = 7 * x
x = 3 * x + x</python>

<p>In the first line, x is set to 2.  Then in the second line, x is
set to 7*x.  To figure out what this stores in x, Python looks up what
was already stored in x.  It finds 2 was stored there, so it
multiplies this by 7 as requested, and stores the new value of 14 into
x.  The last line then sets x to 56 (convince yourself, if you are
unsure of why.)  </p>

<p>Assignment statements are used precisely when we do any kind of
computation.  We can multiply x by 2 using the multiplication operator
*, but the resulting code 

<code>2 * x</code>

is an expression, and we note from our syntax tree that an expression
is not a valid line of code.  However, we do have valid lines like
print lines which can print the value of an expression, or assignment
lines, which can store the value of an expression.  So if you want to
multiply x by 2, you have to store the result somewhere, and so you
would use an assignment line.  Either you would create a new variable,
maybe called y, and store the value there: 

<code>y = 2 * x</code>

or you might overwrite the old value of x with this new value: 

<code>x = 2 * x</code></p>

      </text>
      
      <section>
	<title>Variable names</title>
	<summary></summary>
	<text>
<p>We've already specified in the syntax discussion what valid
variable names are, but there are a few further points to make: </p>

<p>Remember we said variable names cannot be words that Python treats
as special?  While you're not terribly likely to use them by accident,
it is good to have a complete list handy of what these all are.  So
here you go: </p>

<code>
and           if	    
as	      import	    
assert	      in	    
break	      is	    
class	      lambda	    
continue      not	    
def	      or	    
del	      pass	    
elif	      print	    
else	      raise	    
except	      return	    
exec	      try	    
finally	      while	    
for	      with	    
from	      yield
global</code>


<p>Another possible gotcha is that variable names are case-sensitive: </p>

<code>banana = 2
Banana = 3</code>

<p>will create two completely different variables that can be used
independently.  Likewise, </p>

<code>x = 3
y = 3*X</code>

<p>Will cause an error, since the second assignment tries to use the
variable called X.  We just created a variable called x, but that is
unrelated to the completely different variable called X.  </p>

<p>Finally, even though x, y, z etc. are valid variable names, and
using one-letter names will save on typing, there is a balance between
brevity and perspicuity to be struck: Imagine you're reading someone
else's code and you come upon a line like: </p>

<code>a = mass * radius * radius * roll_rate * roll_rate / 5 + mass * velocity * velocity / 2</code>

<p>You'd say--great, you're doing some physics.  You've got some
object with mass, radius, velocity, rolling, and you've stored these
quantities in sensibly named variables called mass, radius, roll_date,
and velocity, and you're doing some massive computation involving all
of these, and you're storing it in some variable called a.  That's all
nice, but what the heck is this thing you're computing supposed to
mean?  How much more obvious is this:</p>

<code>rolling_sphere_kinetic_energy = mass * radius * radius * roll_rate * roll_rate / 5 + mass * velocity * velocity / 2</code>

<p>Obviously that could end up being a lot of typing to use this
variable repeatedly in the future, but it's worth thinking about.
Even KE would be a better name here than just a. </p>

<p>Beyond just making the names meaningful, there are differing
conventions found in the wild regarding naming.  In this book, if a
variable name is supposed to be a sequence of words (like above, when
we wanted to name a variable as 'rolling sphere kinetic energy'), we
will have all the words be lower-case and separated by underscores
(since spaces are not allowed in variable names).  

<def term='camel-casing'>There is another convention that some people
use, which is to have nothing separate the words but to capitalise the
first letter of each word, as in
<code>RollingSphereKineticEnergy</code>

This is called

<b>camel-casing</b>.</def></p>
	</text>
	
      </section>
      <section>
	<title>Expressions</title>
	<summary></summary>
	<text>
<p>The right hand side of an assignment also bears a little more
discussion: expressions.  We said that an expression was any variable
name, number, string, or valid combination thereof using arithmetic
operations.  </p>

<p>Any expression has a <b>value</b>which is what is stored in the
variable during an assignment.  For example, 

<code>x = 2 * 3</code>

stores 6 into x because the value of the expression <pre>2 * 3</pre>
is 6.  The process of determining the value of an expression is called
<b>evaluation</b>, and happens as follows: 

<ul>
  <li>First, find any variable names in the expression and substitute
  in place of those variable names the values currently stored in the
  corresponding variables.  If any of the variables has no stored
  value, give a runtime error.</li>
  <li>Then perform the operations specified in the expressions in the
  with the usual order of operations: 
  <ul>
    <li>Anything in parentheses gets evaluated first</li>
    <li>Any multiplication or division or modulus operations get
    performed left-to-right.  </li>
    <li>Then finally any addition and subtraction happen last.</li>
  </ul>
  If any operation has invalid inputs--e.g. division by zero, or
  attempting to multiply things that are not numbers, give a runtime
  error.
  </li>
</ul>

We can use this to determine what gets stored in x in the following case:

<python>x = 4
y = x + 1
x = 2
x = 5*x + 2*(3 - y)</python>

The first assignment sets x to 4.  The second one sets y to whatever
is the value of x + 1.  To evaluate this expression, we plug in the
current value of x (namely 4) in place of the name 'x' in this
expression, yielding 4 + 1, and then we perform the arithmetic to get
a value of 5.  So the second assignment assigns the value 5 to y.  The
third assignment stores the value 2 in x.</p>

<p>Finally, to find out what the last assignment stores in x, we need
to evaluate the last expression

<code>5*x + 2*(3 - y)</code>

To do this, we again plug in the current values of x and y in place of
their names: x is currently 2, and y is currently 5, so we get: 

<code>5*2 + 2*(3 - 5)</code>

Then we're back to a normal grade-school problem, whose answer is 10 -
4 = 6.  </p>

<p>In addition to numbers, expressions are also allowed to use strings.
For instance: 

<code>'Hello world!'</code>

is a valid expression, and hence 

<code>s = 'Hello world!'</code>

is a valid assignment.  The only caveat is that arithmetic operations
and strings rarely make sense.  For example, adding a number to a
string isn't OK, so 

<code>'Hello' + 2</code>

is not a valid expression and will create a runtime error.  Likewise, 

<code>'hello' * 'aerodrome'</code>

is not a valid expression and will similarly elicit an error.  </p>

<p>We can, however, add two strings: 

<code>'hello' + 'world'</code>

is a valid expression, and its value is the 

<def term='concatenation'><b>concatenation</b> (i.e. sticking the two
strings together to make one long string) of the two strings</def>:
'helloworld'</p>

<p>So consider the following examples: </p>

<python>x = Hello world!
y = z+1
z = 3+&quot;hello&quot;</python>

<p>The variable names on the left sides are fine, but all three
expressions are invalid.  The first one looks like it is meant to be a
string, but because it is not enclosed in quotation marks, Python
doesn't realise this and instead tries to interpret it as variable
names.  But variable names cannot contain spaces or !s, so this falls
flat too, and Python gives up an error.  </p>

<p>The second looks valid--it is a combination of a variable name and a number using the operator +.  But we never defined a value for z!  So Python will try to store the value of this expression in y.  To do this, it will look up what we stored in z and try to add 1 to it.  And this will fail, because we never stored anything at all in z.  </p>

<p>The third example contravenes the weasel-word in the syntax
definition: We required only &quot;valid&quot; combinations of
variables, numbers, and strings.  Obviously adding two numbers is a
&quot;valid&quot; combination, but exactly what else counts?
Certainly almost any arithmetic operation should work on any numbers
or variables that store numbers.  For instance, </p>

<code>x = 1+1
y = 78/x</code>

<p>As mentioned, division (namely, / and %) when the right operand is
0 will cause an error, since as in mathematics generally, dividing by
zero does not make sense to a computer: </p>

<code>x = 4
y = x/2-2
z = x % y</code>

<p>errors: </p>

<figure><description>Error message when this code is run in
IDLE</description><caption>A division-by-zero
error</caption></figure>

<p>Further, if you try to operate on a number and a string, this is not going to go well: </p>

<code>x = &quot;hello&quot;
y = 89/x</code>

<p>will both produce errors.  </p>

<figure><description>Error message when this code is run in
IDLE</description><caption>Type errors</caption></figure>
	</text>
	
      </section>
      <section>
	<title>Strings</title>
	<summary></summary>
	<text>
<p>Recall we defined a string as any sequence of characters contained
inside single-quotes.  It is a type of expression whose value is the
text inside the single quotes.  But what if we that text to contain a
single quote?  For instance, </p>

<pre>print(&quot;hi&quot;)</pre>

<p>prints: </p>

<code>hi</code>

<p>But what if we want to print the following: </p>

<code>&quot;hi&quot;, he said</code>

<p>We might try </p>

<code>print(&quot;&quot;hi&quot;, he said&quot;)</code>

<p>But Python understands this as three things: </p>

<p>The string &quot;&quot;, which contains no text, followed by the
variable called hi (since this is outside any quotes, so is not a part
of the string), followed by the string &quot;, he said&quot;.
Disaster follows: </p>

<figure><description>Error message generated by this
code</description><caption>Failure to string</caption></figure>

<p>To include a quote, then, you need to <def term='escape'><b>escape</b>
it--that is, you precede it in the string with a backslash</def>.  In
general, backslash is the string escape character, meaning that
whatever character comes after it doesn't have its usual meaning, but
has some special meaning.  The usual meaning of ' is 'this is the
boundary of a string', but if we preceed it with a backslash, then its
meaning just becomes just 'the single-quote character'.  So </p>

<pre>print(&quot;\&quot;hi\&quot;, he said&quot;)</pre>

<p>accomplishes the desired result.  Similarly, if we want to store a
string that contains multiple lines, like the string</p>

<code>XXO
_O_
OX_</code>

<p>which might represent a tic-tac-toe board in a game we're progrmaming.  </p>

<p><def term='newline'>It turns out that if we escape the character n,
when escaped, has the special meaning of `the <b>newline</b>
character'--that is, a character which represents going to another
line.  </def> Thus </p>

<code>print(&quot;XXO\n_O_\nOX_&quot;)</code>

<p>prints the above.  </p>
	</text>
	
      </section>

    </section>
    <section>
      <title>Print</title>
      <summary></summary>
      <text>
<p>Now that we know what expressions are, print is reasonably
straightforward: it simply prints to the screen the value of the
expression it is given: </p>

<python>print("hello")
x = 4
y = "blah";
print(x*2/5)
print(y+"zzzzz")</python>

<p>prints</p>

<code>hello
1.6
blahzzzzz</code>

<p>We can use it to print the value stored in a variable</p>

<python>print("Hello")
x = 2
print(x-3)
print(x)</python>

<p>A common use-case for print beyond just printing a final answer is
debugging: if we have a program that is misbehaving and we want to get
some idea of what is happening, we can insert a print statement in the
middle.  For instance, suppose we accidentally wrote our 3x+1 program
thus:
</p>

<python>x = 27
while(x != 1):
   y = x / 2
   if(y == 0):
      x = x / 2
   else:
      x = 3 * x + 1
   print(x)
print("Done!")</python>

<p>Then we would see printed </p>

<code>27
82
247
...</code>

<p>and more numbers that would keep growing forever.  </p>

<p>If we wanted to know what was happening in more detail, we could think: y is supposed to be either 0 or 1, telling us whether x was even or odd.  So let us confirm that this is happening by printing y during the loop as well: </p>

<python>x = 27
while(x != 1):
   y = x / 2
   if(y == 0):
      x = x / 2
   else:
      x = 3 * x + 1
   print(y)
   print(x)
print("Done!")</python>

<p>And we see printed </p>

<code>13.5
82
41.0
247
123.5
742
371.0
2227
1113.5
6682
3341.0
20047
10023.5
60142
...</code>

<p>So something has gone wonky, since we shouldn't be seeing any decimals in the procedure run normally.  To make it even more clear, we'll add in some more print statements to show us which numbers being printed were x and which were y: </p>

<python>x = 27
while(x != 1):
   y = x / 2
   if(y == 0):
      x = x / 2
   else:
      x = 3 * x + 1
   print("here is y: ")
   print(y)
   print("behold x: ")
   print(x)
print("Done!")</python>

<p>Giving: </p>

<code>here is y: 
13.5
behold x: 
82
here is y: 
41.0
behold x: 
247
here is y: 
123.5
behold x: 
742
here is y: 
371.0
behold x: 
2227
here is y: 
1113.5
behold x: 
6682</code>

<p>So we see that instead of being 0 or 1, y is just being set to some crazy, often decimal values.  So which line could possibly be wrong except the line that assigns a value to y?  </p>

<p>So we see that </p>

<code>   y = x / 2</code>

<p>should have been </p>

<code>   y = x % 2</code>

<p>and then all is well.  </p>

      </text>
      
    </section>
    <section>
      <title>Flow control</title>
      <summary></summary>
      <text>
	Flow-control lines are lines that control the order in which
	the lines following it get executed.  The two kinds of
	flow-control we introduce here are if/else lines and while
	lines:
      </text>
      <section>
	<title>if/else</title>
	<summary></summary>
	<text>
<p>The if statement exists for the following use-case: Imagine we're writing a search engine, and we have a variable that stores the word the user is searching for.  It might have come from either poems.txt or raps.txt, and we need to determine which.  So to display the answer, we'll have to have both the line</p>

<code>print(&quot;poems.txt&quot;) </code>

<p>and the line</p>

<code>print(&quot;raps.txt&quot;)</code>

<p>somewhere in our code.  But we definitely don't want both of them to run--we only want one to run, depending on which file the word was found in.  This is the job of the if statement.  </p>

<p>If you recall, an if/else statement is: </p>

<code>if(<i>test</i>): 
   indented lines
else: 
   indented lines</code>

<p>and it runs the first set of indented lines if the test succeeds,
and the second set if the test fails.</p>

<p>So if we can contrive a test that will tell us whether the
searched-for word is in poems.txt or raps.txt, we'll be set: We can
then put the first print statement 

<code>print(&quot;poems.txt&quot;)</code>

in the first set of indented lines, and the second print statement: 

<code>print(&quot;raps.txt&quot;)</code>

in the second set.  </p>

<p>But these are supposed to go in as <i>indented</i> lines, so we return
to our syntax tree to recall what this means: They have to be
preceeded with three spaces more than the previous line.  There were
no spaces at the beginning of the if line, so to indent the print
lines, we given them three spaces at the beginning, like so: 

<code>if(<i>test</i>): 
   print(&quot;poems.txt&quot;)
else: 
   print(&quot;raps.txt&quot;)</code>

(We still don't know what the test is supposed to be, but we'll
discuss that later.)</p>

<p>For if statements in general, the semantic meaning of the
indentation makes it very important, and often a source of subtle
bugs: </p>

<python>x = 2
if(x == 2): 
   print(&quot;x is two&quot;)
else:
   print(&quot;x is not two&quot;)
print(&quot;potato&quot;)</python>

<p>outputs</p>

<code>x is two
potato</code>

<p>whereas </p>

<python>x = 2
if(x == 2): 
   print(&quot;x is two&quot;)
else:
   print(&quot;x is not two&quot;)
   print(&quot;potato&quot;)</python>

<p>outputs only</p>

<code>x is two</code>

<p>because the line </p>

<code>print(&quot;potato&quot;)</code>

<p>is indented, which puts it in the block of lines that only get
executed if the test fails.  And since the test is testing whether x
is equal to 2, the test does not fail.  </p>

	</text>
      </section>
      <section>
	<title>tests</title>
	<summary></summary>
	<text>
<p>So what kinds of tests can we use in if lines?  The syntax tree
tells us that they have to look like 

<code><i>expression</i> <i>comparison</i> <i>expression</i></code>

We already know what expressions are, and our syntax tree tells us
that comparisons are any of: 

<code>&lt;, &gt;, &lt;=, &gt;=, ==, !=</code>

which have the following meanings: 

<table>
<tr><td>Comparison operator</td><td>Meaning</td></tr>
<tr><td>&lt;</td><td>Less than</td></tr>
<tr><td>&gt;</td><td>Greater than</td></tr>
<tr><td>&lt;=</td><td>Less than or equal to</td></tr>
<tr><td>&gt;=</td><td>Greater than or equal to</td></tr>
<tr><td>==</td><td>Equal to</td></tr>
<tr><td>!=</td><td>Not equal to</td></tr>
</table>
</p>

<p>On either side of the comparison operator can be an expression.
The test is said to <def term='succeed (tests)'><b>succeed</b> or to
<b>evaluate to true</b> if the values of the two expressions do in
fact compare in the way that the comparison operator dictates</def>.
<def term='fail (tests)'>If they do not, then the test is said to
<b>fail</b> or to <b>evaluate to false</b></def>.</p>

<p>So for example, we can test if 2*x is greater than 5 with the test: </p>

<code>2*x > 5</code>

<p>We can test if the variable x stores the string &quot;hello&quot; with </p>

<code>x == &quot;hello&quot;</code>

<p>If we have three variables x, y, and z, which all store numbers, and we want to print something if x + y is not the same as z, we can do: </p>

<code>if(x+y != z):
   print(&quot;something&quot;)
</code>

<p>One final dumb example is </p>

<code>if(1 == 1):
   print(&quot;hello&quot;)
else: 
   print(&quot;something is wrong with the universe&quot;)</code>

<p>This is indeed a valid test: Numbers are valid expressions, and ==
is a valid comparison, so 1 == 1 is a valid test.  But it should
always succeed (unless something goes wrong with the universe), so the
above program should be just a very complicated way of writing the
entirely equivalent code: </p>

<code>print(&quot;hello&quot;)</code>

	</text>
      </section>
      <section>
	<title>while</title>
	<summary></summary>
	<text>
<p>Finally, we get to the last flow-control statement that we'll talk about here, namely while.  While is how you get a block of lines repeated several times: </p>

<code>while(test): 
   lines that you want to run for as long as the test holds true
   (the test is re-run every time we get to the end of the indented lines)</code>

<p>This comes in handy when, as an example, we want to print 20 smiley faces followed by a smirk.  We could use 21 print statements: </p>

<python>print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":)")
print(":/")</python>

<p>However if we wanted to print 100 smileys, our program would get rather long, and it may be harder to ensure we got exactly 100 print statements in there.  To simplify this dramatically, we can instead use a while statement.  This requires some thought, however: The while statement will repeat the indented block as long as the test is true.  So clearly we want the print line to be in the indented block: </p>

<code>while(something):
   print(&quot;:)&quot;)
print(&quot;:/&quot;)</code>

<p>But what should the something be?  We want the indented block to repeat 20 times, so the something should be a test that is true the first 20 times it is run, but not the 21st time.  One way to accomplish this is to have a counter variable that counts how many times the indented block has been run.  When the program starts, we'll set the counter to 0: </p>

<code>counter = 0
while(something): 
	print(&quot;:)&quot;)
print(&quot;:/&quot;)</code>

<p>Except now, each time the block is run, we want the counter to increase by 1.  An assignment that can increase the counter by 1 is: </p>

<code>counter = counter + 1</code>

<p>so if we put this inside the indented block, it will be run each time the indented block is run: </p>

<code>counter = 0
while(something): 
	print(&quot;:)&quot;)
	counter = counter + 1
print(&quot;:/&quot;)</code>

<p>Now finally, what should the something be?  The first time the while block is run, counter will start as 0 and get updated to 1.  The second time, it will start as 1 and be updated to 2.  The third time, the counter will start as 2 and be updated to 3 during the execution of the block.  So if the something is </p>

<code>counter &lt; 3</code>

<p>then after the third run of the block, counter will be 3, so the test will fail, and the block will not be repeated a fourth time, and the line will proceed to the line </p>

<code>print(&quot;:/&quot;)</code>

<p>Thus if we wanted to print three smileys and then a smirk, we would do: </p>

<python>counter = 0
while(counter &lt; 3): 
   print(":)")
   counter = counter + 1
print(":/")</python>

<p>We can double-check our understanding of what happens by single-stepping this program: </p>

<table>
<tr>
<td>Current line</td>
<td>Why we went to this line</td>
<td>Variables after current line runs</td>
<td>Output so far</td>
</tr>

<tr>
<td>counter = 0</td>
<td>It was the next line</td>
<td>counter = 0</td>
<td></td>
</tr>

<tr>
<td>while(counter &lt; 3): </td>
<td>It was the next line</td>
<td>counter = 0</td>
<td>
</td>
</tr>

<tr><td>   print(&quot;:)&quot;)</td>
<td>counter was &lt; 3</td>
<td>counter = 0</td>
<td>:)</td></tr>

<tr>
<td>   counter = counter + 1</td>
<td>It was the next line</td>
<td>counter = 1</td>
<td>:)</td>
</tr>

<tr>
<td>   print(&quot;:)&quot;)</td>
<td>We reached the end of the while block, but counter was &lt; 3, so we go back to the start</td>
<td>counter = 1</td>
<td>:)
:)</td>
</tr>

<tr>
<td>   counter = counter + 1</td>
<td>It was the next line</td>
<td>counter = 2</td>
<td>:)
:)</td>
</tr>

<tr>
<td>   print(&quot;:)&quot;)</td>
<td>We reached the end of the while block, but counter was &lt; 3, so we go back to the start</td>
<td>counter = 2</td>
<td>:)
:)
:)</td>
</tr>

<tr>
<td>   counter = counter + 1</td>
<td>It was the next line</td>
<td>counter = 3</td>
<td>:)
:)
:)
</td>
</tr>

<tr>
<td>print(&quot;:/&quot;)</td>
<td>counter was not &lt; 3</td>
<td>counter = 3</td>
<td>:)
:)
:)
:/</td>
</tr>
</table>

<p>Thus to accomplish the original goal, we can use the program: </p>

<code>counter = 0
while(counter &lt; 20): 
	print(&quot;:)&quot;)
	counter = counter + 1
print(&quot;:/&quot;)</code>

<p>This pattern of having a counter incrementing by 1 in a while loop is very common, and you should bear it closely in mind for the future, but it is not the only paradigm for while loops.  For example, we can use a while loop to print all the powers of 2 less than a thousand: </p>

<p>x = 1
while(x &lt; 1000):
	print(x)
	x = 2*x
print(&quot;Done&quot;)</p>

<p>If you're not comfortable with why this program accomplishes this goal, single-step it in the same manner as before to see.</p>

<p>Finally, in the spirit of the last dumb if/else example, we also have a dumb while loop example.  Remember, 1 == 1 is still a valid test, so </p>

<code>while(1 == 1):
   print(&quot;:)&quot;)</code>

<p>is a valid while loop.  Since the test is always true, and the while statement is supposed to repeat the indented lines for as long as the condition is true, it will print smileys forever.  This is called an infinite loop.  They can happen intentionally when you're just trying to be infinitely happy, but they are generally a run-time error (i.e. part of a valid program that provides undesirable behaviour when run), and are not always as obvious as that first example might lead you to believe.  For instance: </p>

<code>x = 49
while(x*x % 4 == 3):
   x = x + 1
   print(x)</code>

<p>Does this program infinite-loop or not?</p>

	</text>
      </section>
      
    </section>
        <section>
	  <title>Comments and whitespace</title>
	  <summary></summary>
	  <text>
	    <p><def term="whitespace">As you may have gathered from previous examples that
	    inadvertently included blank lines, python ignores any
	    line that is blank, or any line that includes nothing but
	    spaces or tabs.  Such lines are called <b>whitespace</b>
	    (presumably because the background colours for many text
	    editors is white, and so the blank space is
	    white)</def>.</p>

	    <p><def term="comment">Python will also ignore anything
	    after a '#' character on any line.  Text preceeded by a
	    '#' can therefore be used to annotate the program,
	    explaining what it does inline.  These pieces of
	    explanatory text are called <b>comments</b>.</def></p>
	  </text>
	</section>
  </section>

  <section>
    <title>Simple examples</title>
    <text>
      <p>Now we set about writing some simple programs.  This happens
      in two stages, corresponding to the previous two sections:
      turning the problem into a computer-friendly algorithm, and then
      writing that algorithm in a computer-friendly language, namely
      Python.</p>
    </text>

      <section>
	<title>Factorial</title>
	<summary></summary>
	<text>
	  <p><b>Introduction: </b></p>

	  <p>The factorial is a mathematical operator that takes in a
	  single positive integer (1, 2, 3, ...) and outputs the
	  product of all the positive integers at or below the input.
	  The factorial of 5 is written as &quot;5!&quot;.  So 5! = 5*4*3*2*1 =
	  120, and 10! = 10*9*8*7*6*5*4*3*2*1 = 3628800.  In this
	  example, we wish to write a program that will compute
	  27!.</p>

	  <p><b>Algorithm: </b></p>
	  
	  <p>The definition of factorial above is completely
	  unambiguous, and is an adequate algorithm for telling a
	  human how to compute factorials.  However we just saw all
	  the things we can tell a computer how to do, namely
	  assignment, print, if, if/else, and while.  You'll note that
	  `multiply the integers 1 through 10' is not on that list, so
	  we need to find a way of telling the computer how to compute
	  27! using these simple operations.</p>

	  <p>Well, this is easy: Clearly we want to print the product
	  1*2*3*...*27.  If we reference our chart above, we see that
	  we are allowed to print any expression.  But what was an
	  expression?  It was any number, string, variable, or
	  combination thereof using operations +, -, *, /, %.  Aha!
	  So 1*2*3*4*5 is an expression--it is a combination of
	  numbers using the operation *.  Therefore: </p>

	  <p><b>Program: </b></p>

<python>print(1*2*3*4*5*6*7*8*9*10*11*12*13*14*15*16*17*18*19*20*21*22*23*24*25*26*27)</python>

          <p><b>Debrief: </b></p>

	  <p>That was all very good, except now say I want to know
	  what is 39!  Now I have to make non-trivial and tedious
	  changes to the program.  It is still easier than multiplying
	  30-digit numbers, but definitely not as easy as it could be.
	  What we would like is a program that looks like:</p>

<code>input = 27
... some things
... some more things
print(answer)</code>


<p>That is, the program starts by storing the desired input value in a
variable, and then whatever that value is, it does some computation
and eventually ends up with the factorial of this initial value stored
in the variable called answer.</p>

<p>This way, if we decide later that we instead wanted 39!, we can just change the first line to 

<code>input = 39</code>

and leave the rest of the program untouched, and still get the correct answer.  </p>

<p><b>Algorithm, Mark II: </b></p>

<p>The above desired form of the program tells us the first and last steps of the algorithm: </p>

<code>Step 1: Store the number whose factorial we want in a variable called input.  
...
Step last: print the number stored in the variable answer.  
</code>

<p>So clearly at some point we'll need to make a variable called
answer.  May as well make that step 2.  So step 2 will be an
assignment (a valid operation), setting answer equal to...what?
Clearly we cannot just say <code>answer = input!</code>, since ! is not
one of the operations that Python understands.  So let's just start
small--answer = 1</p>.

<code>Step 1: Store the number whose factorial we want in a variable called input.  
Step 2: Store the number 1 in the variable answer.
...
Step last: print the number stored in the variable answer.  
</code>

<p>Now, clearly what we need to do is to first multiply answer by 2,
and then by 3, and then by 4, and so on until we get to 27.  So let us
store the thing we're multiplying by in yet another variable.  This
variable will be counting up from 2, and will be multiplied into
answer at each step.  So we'll call this variable counter, and since
the first multiplication will be by 2, we'll start this variable at 2.
</p>

<code>Step 1: Store the number whose factorial we want in a variable called input.  
Step 2: Store the number 1 in the variable answer.
Step 3: Store the number 2 in the variable counter.
...
Step last: print the number stored in the variable answer.  </code>


<p>Now we want to increment counter repeatedly until it is 27, or, more precisely, until it matches whatever is in the variable input.  Intuitively this process looks like: 

<code>answer = answer*counter
counter = counter + 1
answer = answer * counter
counter = counter + 1
answer = answer * counter
counter = counter + 1
answer = answer * counter
counter = counter + 1
...</code>

except we want this to stop when counter exceeds input.  </p>
<p>So: 

<code>Step 1: Store the number whose factorial we want in a variable called input.  
Step 2: Store the number 1 in the variable answer.
Step 3: Store the number 2 in the variable counter.
Step 4: Repeat the following until counter is greater than input: 
	Substep 1: Replace answer with answer * counter
	Substep 2: Increment counter by 1
Step 5: print the number stored in the variable answer.  </code>
</p>

<p>And recall that this 'repeat the following' sort of step is
something that we can tell the computer to do--this is what the while
instruction does!  So we do: </p>

<p><b>Program, Mark II: </b></p>

<python>input = 27
answer = 1
counter = 2
while(counter &lt; input): 
   answer = answer * counter
   counter = counter + 1
print(answer)</python>

<p>Let us single-step this program with a slightly smaller input: 4.  So the program should compute 4! = 4*3*2*1 = 24 and print this result.  Let us see: </p>

<table><tr>
<td>Current line</td>
<td>Why we went to this line</td>
<td>Variables after current line runs</td>
<td>Output so far</td>
</tr><tr>
<td>input = 4</td>
<td>It was the next line</td>
<td>input = 4</td>
<td></td>
</tr><tr>
<td>answer = 1</td>
<td>It was the next line</td>
<td>input = 4
answer = 1</td>
<td></td>
</tr><tr>
<td>counter = 2</td>
<td>It was the next line</td>
<td>input = 4
answer = 1
counter = 2</td>
<td></td>
</tr><tr>
<td>while(counter &lt; input):</td>
<td>It was the next line</td>
<td>input = 4
answer = 1
counter = 2</td>
<td></td>
</tr><tr>
<td>answer = answer * counter</td>
<td>counter was less than input</td>
<td>input = 4
answer = 2
counter = 2</td>
<td></td>
</tr><tr>
<td>counter = counter + 1</td>
<td>It was the next line</td>
<td>input = 4
answer = 2
counter = 3</td>
<td></td>
</tr><tr>
<td>answer = answer * counter</td>
<td>We reached the end of the while block, but counter was still less than input, so we go back to the start</td>
<td>input = 4
answer = 6
counter = 3</td>
<td></td>
</tr><tr>
<td>counter = counter + 1</td>
<td>It was the next line</td>
<td>input = 4
answer = 6
counter = 4</td>
<td>
</td>
</tr><tr>
<td>print(answer)</td>
<td>We reached the end of the while block, and counter was not less than input, so we proceed to the next line</td>
<td>input = 4
answer = 6
counter = 4</td>
<td>6</td>
</tr></table>

<p>So something went slightly wrong!  That is, a runtime error has occurred!  </p>

<p>We wanted the last step to be <pre>answer = answer * 4</pre>.  But
counter was set to 4 at the end of the loop body, and then because
counter &lt; input was false (4 is not less than 4), the next iteration
of the loop, which would have done the multiplication by 4, did not
run.</p>

<p><def term="off-by-one error">This is a particularly notorious kind of runtime error called an
<b>off-by-one error</b></def>.  There are a couple of possible fixes.  The simplest
is that we want the loop to run when counter is less than input or
equal to it.  To get this behaviour, we replace &lt; by &lt;= to get:

<python>input = 27
answer = 1
counter = 2
while(counter &lt;= input): 
answer = answer * counter
counter = counter + 1
print(answer)
</python>

Another possible fix, the analysis of which is left as an exercise, is the following: 

<python>input = 27
answer = 1
counter = 1
while(counter &lt; input): 
counter = counter + 1
answer = answer * counter
print(answer)</python>
</p>

<p><b>Debrief: </b></p>

<p>So finally we have a factorial program that we can easily use to compute larger factorials too: 

<python>input = 50
answer = 1
counter = 2
while(counter &lt;= input): 
answer = answer * counter
counter = counter + 1
print(answer)</python>

Later we will learn how to make the program ask for and receive input from the person running the program (as opposed to now, when you have to actually change the program to affect the computation it runs).  Having written the program not using any foreknowledge of the value of the input, it will be easy plug in the code for reading like: 

<code>[get user's input and store its value in the variable input]
answer = 1
counter = 2
while(counter &lt;= input): 
answer = answer * counter
counter = counter + 1
print(answer)</code>
</p>
	</text>
      </section>
      <section>
	<title>Primality testing</title>
	<summary></summary>
	<text>
	  <p><b>Introduction: </b></p>

	  <p>A prime number is a positive integer that is not evenly
	  divisible by any other positive integer than itself and 1.
	  For instance, 12 is evenly divisible by 4, and therefore is
	  not prime, whereas 13 is prime.  Prime numbers are of
	  interest because every number can be built out of primes: 12
	  is not prime, as it is evenly divisible by 4: 12 = 4*3.  And
	  4 is not prime--it is evenly divisible by 2: 4 = 2*2, so we
	  can break up 12 further: 12 = 2*2*3.  </p>

	  <p>It is sometimes of great interest to determine whether a
	  number is prime.  In this section, we shall write a program
	  capable of doing so.  Specifically, the program shall start
	  with a line like 

	  <pre>n = 101231</pre>

	  and shall, at the end, print either &quot;n is prime&quot; or &quot;n is
	  not prime&quot; depending on the result of its test. </p>

	  <p><b>Algorithm: </b></p>

	  <p>We are given a number, say stored in a variable called n.
	  We want to test if n is prime.  As before, we start with the
	  definition: If it is prime, then no number between 2 and n-1
	  inclusive divides into n evenly.  Thus we can step through
	  these numbers in sequence, as we did with the counter
	  variable in the previous example, and test each one in turn
	  to see if it divides into n evenly.</p>

<code>Step 1: n = 10000001
Step 2: counter = 2
Step 3: Repeat the following as long as counter &lt; n: 
	Substep 1: Test if counter divides into n evenly
	Substep 2: Increment counter</code>

	<p>This seems to cover all the things required by the
	definition of `prime', but it is still quite incomplete: What
	do we do if counter does divide evenly into n?  And for that
	matter, what do we do at the end of the loop?</p>

	<p>In the course of step 3, we'll discover whether or not n was
	prime.  If we store this information somehow, then at the end
	of the loop we can print out the result based on this stored
	information.  To this end, we'll also create a variable called
	is_prime.  We'll start with it set to 1, and if we find a
	divisor, we'll set it to 0.  Then, at the end, we'll test the
	value of is_prime and print as appropriate.</p>

<code>Step 1: n = 10000001
Step 2: counter = 2
Step 3: is_prime = 1
Step 4: Repeat the following as long as counter &lt; n: 
	Substep 1: Test if counter divides into n evenly.  If it does, set is_prime to 0
	Substep 2: Increment counter
Step 5: If is_prime is 1, print &quot;n is prime&quot;
Step 6: If is_prime is 0, print &quot;n is not prime&quot;</code>

        <p><b>Program:</b></p>

	<p>To turn this into an honest program is reasonably
	straightforward.  The elements we have not yet used are the
	tests, which are accomplished with the if/else instructions.
	How to see if counter divides n evenly?  One way to do it is
	to divide n by counter and see if the quotient is an integer.
	However we don't yet have any operation for testing &quot;is this
	variable an integer&quot;, so that's no good for now.  Another way
	would be to divide n by counter and see if the remainder is 0.
	Recall we can get the remainder of this division with n %
	counter.  So we get:</p>

<python>n = 1000001
counter = 2
is_prime = 1
while(counter &lt; n):
   if(n % counter == 0): 
      is_prime = 0
   counter = counter + 1
if(is_prime == 1):
   print("n is prime")
if(is_prime == 0):
   print("n is not prime")</python>

        <p><b>Debrief: </b></p>

	<p>This program is less efficient than it could be in many
	ways.  You can probably think of improvements already--for
	instance, we don't have to test all the possible divisors
	counter &lt; n--we can certainly get away with testing only to
	n/2, since if n/2 evenly divides n, then 2 also evenly divides
	n, so we would have caught that already.  Also, none of the
	numbers between n/2 and n can possibly divide evenly into n.</p>

	<p>The general question of whether this problem had a truly
	efficient solution remained frustratingly unanswered for years
	until an undergraduate project by two students together with
	their advisor at the Indian Institute of Technology found an
	algorithm that they could prove would get the answer quickly
	in all cases.</p>
	</text>
      </section>
      <section>
	<title>Counting digits</title>
	<summary></summary>
	<text>
	  <p><b>Introduction: </b></p><p>Starting with some number,
	  count how many digits are required to write the number
	  down.  For example, with the number 1045, the answer would
	  be 4.</p>

	  <p><b>Algorithm: </b></p>

	  <p>This is one of those problems that is very easy to do by
	  hand: When you have a number, it is given to you as a list
	  of digits, so you just count the digits on the paper--no
	  sweat.  But to a computer, 'look at how many digits are in
	  this number' isn't one of the operations we are allowed to
	  do to numbers.  All we can do is add, subtract, multiply,
	  and divide, and so to solve the problem with a computer, we
	  need to think of how to solve it with only these operations
	  available to us.  </p>

	  <p>So, to get the number of digits in a number
	  mathematically, we can repeatedly divide it by 10 until it
	  gets below 1.  The number of times we have to do this is the
	  number of digits in the number.  For instance, 9 / 10 = 0.9,
	  so we only have to divide once, so the number 9 has one
	  digit.  128 / 10 = 12.8, 12.8 / 10 = 1.28, 1.28 / 10 =
	  0.128.  So it takes three divisions to get to below 1, and
	  indeed, 128 has three digits.</p>

	  <p>To accomplish this programmatically, we will need two
	  variables--one to store the number that we will repeatedly
	  divide--say this is called <pre>n</pre>, and another to
	  store how many times we've divided so far--say this one is
	  called <pre>digit_count</pre>.  Then we can write the
	  algorithm more precisely as: </p>

<code>Step 1: n = 1238129 (or whatever)
Step 2: digit_count = 0
Step 3: Repeat the following as long as n > 1:
	Substep 1: Increment digit_count
	Substep 2: Divide n by 10
Step 4: Print digit_count</code>

<p><b>Program: </b></p>

<python>n = 1238129
digit_count = 0
while(n > 1):
   digit_count = digit_count + 1
   n = n/10
print(digit_count)</python>

<p>You would be right to worry about an off-by-one error--do we start
digit_count at 0 or at 1?  We can tell by single-stepping the program
in a simple case, as we did before, or you can run the program with a
few different inputs as examples.  Convince yourself that we are OK.
</p>

<p>There is also a tricky edge-case that may have slipped your notice,
however: Consider what happens when we start with <pre>n = 1</pre>:
First <pre>digit_count</pre> will be set to 0, and then we'll run the
while loop as long as <pre>n > 1</pre>.  But even at the start, this
test fails, as <pre>n = 1</pre>, so <pre>n</pre> is not greater than
1!  So the stuff inside the while loop gets skipped entirely, and the
value of <pre>digit_count</pre>--namely 0--gets printed.  And this is
definitely the wrong answer--the number '1' has 1 digit!  </p>

<p>In fact, this isn't the only issue--this problem shows up whenever
<pre>n</pre> gets set to 1 during execution, for example if it started
at 1000, we would get the wrong answer of 3.  </p>

<p>To fix this, we simply need to realise that we wrote our algorithm
correctly--we stop if n is below 1--but our program doesn't reflect
this--it stops if n is below 1 <i>or if n is equal to 1</i>.  We can
rectify this by telling it to continue with the while loop even when n
is 1:

<python>n = 1238129
digit_count = 0
while(n >= 1):
   digit_count = digit_count + 1
   n = n/10
print(digit_count)</python>

</p>

<p><b>Debrief: </b></p>

<p>We should note that this program doesn't work for non-integers, nor
for integers below 1.  </p>

<p>If you played around with the factorial program, you probably got
the sense that factorials were pretty huge.  To get an idea of how
huge, we can combine our digit-counting program with our factorial
program to find out how many digits are in 99!: </p>

<python>input = 99
answer = 1
counter = 1
while(counter &lt; input): 
counter = counter + 1
answer = answer * counter
n = answer
digit_count = 0
while(n >= 1):
   digit_count = digit_count + 1
   n = n/10
print(digit_count)</python>

	</text>
      </section>
  </section>
  <section>
    <title>Applications</title>
    <text>
      <p> In this section, we'll revisit our three example
      applications of search engine, game console, and cell phone, to
      see how we might start to apply our limited knowledge of Python
      in the direction of creating these systems.  The programs we'll
      write here will only be indicative of the ideas involved, since
      we don't yet know enough of the Python language to provide a
      realistic solution for any of them--for instance, we don't even
      have a way of getting user input without requiring the user to
      edit the program!  But we'll bash on ahead anyway and see what
      we can do:
      </p>
    </text>
    
    <section>
      <title>Search engine</title>
      <text>
	<p>As we discussed in chapter 1, a working search engine solves many different problems--storing lots of files on lots of computers, displaying a search box to millions of people per minute, and more.  Here, we shall suppose we have the files split into words and each word is stored in its own variable, like so:   </p>

<code>file1_name = &quot;Ode on the death of a favourite cat&quot;
file1_word1 = &quot;twas&quot;
file1_word2 = &quot;on&quot;
file1_word3 = &quot;a&quot;
file1_word4 = &quot;lofty&quot;
file1_word5 = &quot;vases&quot;
file1_word6 = &quot;side&quot;
file2_name = &quot;Elegy written in a country churchyard&quot;
file2_word1 = &quot;the&quot;
file2_word2 = &quot;curfew&quot;
file2_word3 = &quot;tolls&quot;
file2_word4 = &quot;the&quot;
file2_word5 = &quot;knell&quot;
file2_word6 = &quot;of&quot;
file2_word7 = &quot;parting&quot;
file2_word8 = &quot;day&quot;</code>

<p>We'll also suppose the word that the user searched for is already stored for us in a variable.  Then the game is just to take each word from each file and compare it to the search word.  </p>

<code>search_word = &quot;the&quot;</code>

<p>Then, to make do the actual searching is just a painful slog of if statements like: </p>

<code>if(search_word == file1_word1): 
   print(file1_name)</code>

<p>So the full program looks like: </p>

<python>search_word = &quot;the&quot;
file1_name = &quot;Ode on the death of a favourite cat&quot;
file1_word1 = &quot;twas&quot;
file1_word2 = &quot;on&quot;
file1_word3 = &quot;a&quot;
file1_word4 = &quot;lofty&quot;
file1_word5 = &quot;vases&quot;
file1_word6 = &quot;side&quot;
file2_name = &quot;Elegy written in a country churchyard&quot;
file2_word1 = &quot;the&quot;
file2_word2 = &quot;curfew&quot;
file2_word3 = &quot;tolls&quot;
file2_word4 = &quot;the&quot;
file2_word5 = &quot;knell&quot;
file2_word6 = &quot;of&quot;
file2_word7 = &quot;parting&quot;
file2_word8 = &quot;day&quot;
if(search_word == file1_word1): 
   print(file1_name)
if(search_word == file1_word2): 
   print(file1_name)
if(search_word == file1_word3): 
   print(file1_name)
if(search_word == file1_word4): 
   print(file1_name)
if(search_word == file1_word5): 
   print(file1_name)
if(search_word == file1_word6): 
   print(file1_name)
if(search_word == file2_word1): 
   print(file2_name)
if(search_word == file2_word2): 
   print(file2_name)
if(search_word == file2_word3): 
   print(file2_name)
if(search_word == file2_word4): 
   print(file2_name)
if(search_word == file2_word5): 
   print(file2_name)
if(search_word == file2_word6): 
   print(file2_name)
if(search_word == file2_word7): 
   print(file2_name)
if(search_word == file2_word8): 
   print(file2_name)</python>
      </text>
    </section>
    <section>
      <title>Game console</title>
      <text>
<p><b>Comparing scores:</b></p>

<p>We started this chapter with an example algorithm for comparing the scores of three players.  We'll now implement this algorithm as a Python program, supposing we have the three scores stored in three variables, say like so: </p>

<code>player1_score = 20
player2_score = 21
player3_score = -1</code>

<p>Recall the algorithm: </p>

<code>If score1 is greater than score2 and score1 is also
greater than score3: Display the text: &quot;PLAYER 1 WINS!&quot;

If not, then if score2 is greater than score1 and score2 is also
greater than score3: Display the text: &quot;PLAYER 2 WINS!&quot;

If not, then if score3 is greater than score1 and score3 is also
greater than score2: Display the text: &quot;PLAYER 3 WINS!&quot;
</code>

<p>So the main difficulty is in performing this combined test, where
we test two things at once.  We can perform one of the tests like:
</p>

<code>if(player1_score > player2_score):
   ...
</code>

<p>But then we need to put the second test of step 1, namely, player1_score > player3_score, somewhere.  The point is that we can break up the algorithm to perform only one test at a time: Instead of

<code>If score1 is greater than score2 and score1 is also
greater than score3: Display the text: &quot;PLAYER 1 WINS!&quot;</code>

We can say

<code>If score1 is greater than score2, then test if score1 is greater
than score3.  If this second test is true, print the text: &quot;PLAYER 1 WINS!&quot;</code>

Thus we get the code:

<code>if(player1_score > player2_score):
   if(player1_score > player3_score):
      print(&quot;PLAYER 1 WINS&quot;)</code>

So for a full version of this program, we get:

<python>player1_score = 20
player2_score = 21
player3_score = -1
if(player1_score > player2_score):
   if(player1_score > player3_score):
      print(&quot;PLAYER 1 WINS&quot;)
if(player2_score > player1_score):
   if(player2_score > player3_score):
      print(&quot;PLAYER 2 WINS&quot;)
if(player3_score > player1_score):
   if(player3_score > player2_score):
      print(&quot;PLAYER 3 WINS&quot;)</python>
</p>

<p><b>Computing distances: </b></p>

<p>As discussed at in chapter 1, one of the things that happens
frequently in a game is that we need to compute distances between
points.  Let us say we are dealing with 2D points, whose coordinates
are stored in variables like:

<code>point1_x = 20
point1_y = 55
point2_x = 10
point2_y = 60</code>

representing point 1 being (20,55) and point2 being (10,60).  </p>

<p>And say we want to see which point is furthest away from the origin--(0,0).  Then the algorithm is straightforward: </p>

<code>Compute the distance of point 1 to the origin and store it in a variable
Compute the distance of point 2 to the origin and store it in another variable
If the first variable is larger than the second, print that point 1 is closer to the origin
If the second variable is larger than the first, print that point 2 is closer to the origin
If the two variables are equal, print that they are the same distance to the origin
</code>

<p>The one problem that presents is that the distance to the origin is given by </p>

<code>sqrt(x1*x1 + y1*y1)</code>

<p>but we don't yet have an operation for square root.  Fortunately,
instead of comparing sqrt(x1*x1 + y1*y1) with sqrt(x2*x2 + y2*y2), we
can just compare, x1*x1 + y1*y1 with x2*x2 + y2*y2, since sqrt is an
increasing function.  So we'll modify our algorithm to not compute the
distances, but rather the square distances, and get the program: </p>

<python>point1_x = 20
point1_y = 55
point2_x = 10
point2_y = 60
square_distance1 = point1_x*point1_x + point1_y*point1_y
square_distance2 = point2_x*point2_x + point2_y*point2_y
if(square_distance1 &lt; square_distance2): 
   print(&quot;Point 1 is closer to origin&quot;)
if(square_distance1 > square_distance2): 
   print(&quot;Point 2 is closer to origin&quot;)
if(square_distance1 == square_distance2): 
   print(&quot;Points are the same distance from the origin&quot;)</python>
      </text>
    </section>
    <section>
      <title>Mobile phone</title>
      <text>
	<p>Recall our earlier discussion of a cell phone with an
	accelerometer--a noisy sensor.  We want to estimate our
	acceleration, but the readings may be affected--sometimes
	rather dramatically, by random noise.  Since the noise is
	equally likely to cause the sensor to overestimate as to
	underestimate, we can take some number of readings from the
	sensor, and instead of taking any individual reading as the
	actual acceleration value, we can take the average of all of
	them.  </p>

	<p>In this example, we suppose we've somehow got 5 readings
	from the sensor stored in some variables for us.  (For the
	moment, we'll just store the values rather than actually read
	them from a sensor, since we're studying how to do the
	averaging, and not yet how to talk to sensors): </p>

<python>
reading_1 = 20
reading_2 = 21
reading_3 = 15
reading_4 = 22
reading_5 = 20
summation = reading_1 + reading_2 + reading_3 + reading_4 + reading_5
average = summation/5
print(&quot;The average is: &quot;)
print(average)
</python>
      </text>
    </section>

    <section>
      <title>Debrief</title>
      <text>
	<p>Obviously none of the preceding examples contains realistic
	production-quality code, but they illustrate with valid Python
	code how to implement some basic search and game-logic
	algorithms.  In the next chapter, we'll learn some more
	advanced constructs that will allow far less cumbersome
	implementations.</p>

	<p>Some unsatisfying features that will be rectified in the next chapter: 
	<ul><li>We didn't allow user input</li>
	<li>Our method of output was only console printing</li>
	<li>The only way of storing a massive collection of values was to use
	a massive number of variables</li>
	</ul>
	Stay tuned!</p>
      </text>
    </section>
  </section>
</section>
